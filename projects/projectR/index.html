<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="프로젝트R에 대한 기여도를 상세하게 기술한 포트폴리오입니다." />
        <meta name="author" content="홍을석" />
        <title>프로젝트R</title>
        <link rel="icon" type="image/x-icon" href="/assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="/css/styles.css?v=20250825_1" rel="stylesheet" />
        
        <link rel="stylesheet" href="/highlight/styles/vs.min.css">
        <script src="/highlight/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand" href="/index.html">
                <span class="d-block d-lg-none">홈</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="/assets/img/profile.jpg" alt="프로필 사진" /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="/index.html">홈</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#about">게임 소개</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#contributions">주요 기여</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#combat-system">전투 시스템</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#architecture-efficiency">아키텍처 개선</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#optimization-stability">최적화</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#content-implementation">콘텐츠 구현</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#growth">성장</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <!-- About-->
            <section class="resume-section" id="about">
                <div class="resume-section-content">
                    <h1 class="mb-0">
                        Project R
                    </h1>
                    <div class="subheading mb-2">
                        BluePotion Games
                    </div>
                     <div class="row align-items-center">
                        <div class="col-lg-7 mb-lg-0 mb-4 pe-lg-4">
                            <div class="ratio ratio-16x9">
                                <iframe src="https://www.youtube.com/embed/slBGNvYOWIA" title="Project R Video" allowfullscreen></iframe>
                            </div>
                        </div>
                        <div class="col-lg-5 ps-lg-4">
                            <div>
                                <p class="mb-2"><strong>Released:</strong> 미정</p>
                                <p class="mb-2"><strong>Developer:</strong> BluePotion Games</p>
                                <p class="mb-2"><strong>Platforms:</strong> PC, Android</p>
                                <p class="mb-2"><strong>Skill focus:</strong> 전투 시스템, 콘텐츠 구현, UI/UX, 아키텍처, 최적화</p>
                                <p class="mb-2"><strong>Time spent on project:</strong> 2023.09 ~ Present</p>
                                <p class="mb-0"><strong>Language & Engine:</strong> C++, Unreal Engine 5</p>
                            </div>
                        </div>
                    </div>
                    <p class="mt-4">
                        본 프로젝트는 <strong>크로스플랫폼(PC 및 모바일)</strong> 기반의 <strong>리니지 라이크(Lineage-like) 스타일 대규모 MMORPG</strong>로, C++과 Unreal Engine 5를 활용해 높은 그래픽 품질과 최적의 성능 구현을 목표로 합니다.
                        2023년 9월부터 클라이언트 개발팀의 팀원으로 합류하여, <strong>전투 시스템, UI/UX, 시스템 아키텍처 설계 및 최적화</strong> 등 게임의 핵심적인 부분들을 담당하고 있습니다.
                        <br><br>
                        <strong>World Partition, Nanite, Gameplay Ability System(GAS)</strong> 등 언리얼 엔진 5의 최신 기술을 적극적으로 활용하고 있으며, UI 개발에는 <strong>MVVM(Model-View-ViewModel) 아키텍처</strong>를 도입하여 코드의 재사용성과 유지보수성을 높였습니다.
                        현재 출시 미정인 비공개 프로젝트라 주요 내용은 텍스트 중심으로 구성했습니다.
                    </p>
                </div>
            </section>
            <hr class="m-0" />
            
            <!-- Contributions -->
            <section class="resume-section" id="contributions">
                <div class="resume-section-content">
                    <h2 class="mb-5">나의 주요 기여</h2>
                    <p class="lead mb-5">
                        프로젝트 R 개발에 주도적으로 참여하여 다음과 같은 핵심 기여를 통해 게임의 완성도와 효율성을 높였습니다.
                    </p>
                    <div class="accordion" id="experienceAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                                    <strong>전투 시스템 설계 및 개선</strong>
                                </button>
                            </h2>
                            <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne">
                                <div class="accordion-body">
                                    <li>State Machine 패턴 적용으로 <strong>전투 프로세스 구조 재편 및 안정성 강화</strong></li>
                                    <li><strong>자동 전투 시스템</strong> 직접 개발로 편의성 및 몰입도 향상</li>
                                    <li>콤보 스킬, 퀵슬롯, 스캔 시스템 구현으로 전투 핵심 기능 고도화</li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                                    <strong>개발 효율성 및 아키텍처 개선</strong>
                                </button>
                            </h2>
                            <div id="collapseTwo" class="accordion-collapse collapse show" aria-labelledby="headingTwo">
                                <div class="accordion-body">
                                    <li>MVVM 구조·공통 UI 컴포넌트 도입으로 코드 재사용 및 <strong>생산성 향상</strong></li>
                                    <li>AI 스크립트 자동 생성 도구로 서버 패킷·데이터 <strong>작업 시간 50% 단축</strong></li>
                                    <li>콘텐츠 스케줄 관리 시스템 구축으로 운영 <strong>안정성 확보</strong></li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">
                                    <strong>게임 안정성 및 최적화 기여</strong>
                                </button>
                            </h2>
                            <div id="collapseThree" class="accordion-collapse collapse show" aria-labelledby="headingThree">
                                <div class="accordion-body">
                                    <li>메모리 누수·댕글링 포인터 버그 수정으로 <strong>안정성·성능 대폭 개선</strong></li>
                                    <li>미니맵 <strong>이벤트 기반 업데이트 전환</strong>으로 <strong>CPU 부하 개선</strong></li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="true" aria-controls="collapseFour">
                                    <strong>다양한 콘텐츠 시스템 구현</strong>
                                </button>
                            </h2>
                            <div id="collapseFour" class="accordion-collapse collapse show" aria-labelledby="headingFour">
                                <div class="accordion-body">
                                    <li>월드맵·필드맵·미니맵 UI 개발로 시각 퀄리티 및 UX 개선</li>
                                    <li>레이드 던전 콘텐츠 구조 모듈화로 <strong>재사용성 극대화</strong></li>
                                    <li>결투·업적·시즌패스·우편·소환 상점 등 <strong>방대한 콘텐츠 개발</strong></li>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Combat System -->
            <section class="resume-section" id="combat-system">
                <div class="resume-section-content">
                    <h2 class="mb-5">전투 시스템 설계 및 개선</h2>
                    <p class="lead mb-4">
                        프로젝트 R의 전투 시스템은 <strong>상태 머신(State Machine)</strong>을 기반으로 설계되어, 복잡한 전투 상황에서도 명확하고 안정적으로 동작합니다. 플레이어의 조작, 자동 전투, 스킬 사용 등 다양한 요소를 유기적으로 결합해 역동적인 전투 경험을 제공합니다.
                    </p>
                    <hr class="my-5">

                    <h3 class="mb-4">전투 프로세스 구조 개선</h3>
                    <p><strong><i class="fas fa-exclamation-triangle text-warning"></i> 문제점:</strong> 여러 조건 분기(if/else)가 중첩된 복잡한 구조로 인해 새로운 기능을 추가하거나 수정할 때 전투 로직이 꼬이는 문제가 자주 발생했습니다.</p>
                    <p><strong><i class="fas fa-wrench text-primary"></i> 해결:</strong> 상태 머신(State Machine) 패턴을 도입하여 전투 프로세스를 '추적', '회전', '공격 대기', '공격 가능' 등 명확한 상태로 나누고, 각 상태의 전환 조건을 명확히 정의하여 재편했습니다. 이를 통해 각 상태는 자신의 로직에만 집중할 수 있게 되어 코드의 복잡도가 크게 낮아졌습니다.</p>
                    <p><strong><i class="fas fa-check-circle text-success"></i> 결과:</strong> 버그 발생률이 감소하고 코드의 가독성과 유지보수성이 향상되어, 새로운 전투 기능을 안정적으로 추가할 수 있는 기반을 마련했습니다.</p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>단일 책임 원칙:</strong> 공격 가능 여부를 판단하는 조건(거리, 각도 등)과 실제 공격 실행 로직을 명확히 분리하여, 각 상태가 하나의 책임만 갖도록 설계했습니다.</li>
                            <li><strong>확장성:</strong> 새로운 공격 패턴이나 조건을 추가할 때 다른 상태에 영향을 주지 않고, 원하는 상태에만 로직을 추가하거나 수정할 수 있도록 만들어 확장성을 높였습니다.</li>
                            <li><strong>명확한 역할 분담:</strong> AttackProcessor는 공격 가능 상태를 판단하고 PlayerController에 이를 통지하며, 실제 공격 실행(서버에 스킬 사용 요청)은 PlayerController가 담당하도록 하여 각 모듈의 역할을 명확히 분담했습니다.</li>
                        </ul>
                        </p>
                    <p class="mt-4">
                        아래는 <strong>상태 머신 패턴</strong>과 <strong>델리게이트(Delegate)</strong>를 활용한 실제 구현 코드의 핵심입니다.
                        상태가 변경될 때마다 해당 로직을 실행하고, 동시에 이 상태 변화를 다른 시스템(플레이어 컨트롤러, UI 등)에 전파하여, 시스템 간의 결합도는 낮추고 확장성은 높이는 구조를 만들었습니다.
                    </p>
                    <pre><code class="language-cpp">// 새로운 공격 상태로 변경하고, 이 변경을 다른 시스템에 알리는(Broadcast) 핵심 로직
void UAttackProcessor::SetAttackState(EAttackState NewState)
{
    if (CurrentState == NewState) return;

    EAttackState PrevState = CurrentState;
    CurrentState = NewState;

    // 상태에 따른 로직 분기 처리
    switch (CurrentState)
    {
        case EAttackState::Trace:   HandleTraceState();   break;
        case EAttackState::Rotate:  HandleRotateState();  break;
        case EAttackState::Attack:  HandleAttackState();  break;
    }

    // 상태 변경을 Delegate로 Broadcast하여,
    // 이벤트를 구독하는 다른 객체(플레이어 컨트롤러, UI 등)에 전파합니다.
    if(OnAttackStateChanged.IsBound())
    {
        OnAttackStateChanged.Broadcast(PrevState, CurrentState);
    }
}
</code></pre>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">자동 전투 및 스킬 시스템</h3>
                    <p>
                        단순히 가장 가까운 적을 공격하는 것을 넘어, <strong>자동 반격, 우선 순위 대상 공격</strong> 등 다양한 옵션을 제공하는 <strong>자동 전투 시스템</strong>의 구현을 담당하여 사용자의 편의성과 게임 몰입도를 높였습니다.
                        또한, 플레이어가 자동 전투 시 사용할 스킬의 순서와 조건을 직접 설정할 수 있는 <strong>커스터마이징 가능한 자동 스킬 시스템</strong>을 개발했습니다. 이 시스템은 스킬의 쿨타임, 비용 등을 실시간으로 체크하여 사이클에 맞는 스킬을 선택하고, 플레이어의 상태 변화에 동적으로 반응하여 전투 효율을 극대화합니다.
                        스킬 사용 로직은 서버와의 긴밀한 통신을 통해 처리되며, 클라이언트는 스킬 사용의 유효성을 검사하고 대상을 결정하여 서버에 요청하는 역할을 수행함으로써 정확성과 안정성을 보장합니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>컴포넌트 기반 아키텍처 설계:</strong> 자동 전투, 스킬, 스캔 등 핵심 기능을 독립적인 컴포넌트로 분리하여 재사용성과 유지보수성을 높였습니다. 각 컴포넌트는 명확한 책임(SRP)을 가지도록 설계하여 코드의 응집도를 높이고 결합도를 낮추는 데 집중했습니다.</li>
                        </ul>
                    </p>
                    <p class="mt-4">
                        아래는 자동 스킬 시스템의 핵심 로직입니다. 플레이어가 설정한 스킬 사이클을 순회하며, 마지막으로 사용한 스킬의 위치를 기억했다가 다음 스킬부터 사용 조건을 검사합니다. 이를 통해 정해진 순서에 따라 지능적으로 스킬을 사용하는 기능을 구현했습니다.
                    </p>
                    <pre><code class="language-cpp">// 자동 전투 시, 정해진 순서에 따라 다음 스킬을 찾는 로직
void UAutoSkillComponent::FindNextSkillToUse()
{
    // SkillCycle 배열을 총 1번만 순회하도록
    for (int32 i = 0; i &lt; SkillCycle.Num(); ++i)
    {
        // 1. 마지막에 사용한 스킬의 다음 인덱스부터 순회 시작
        int32 CurrentIndex = (LastUsedSkillIndex + 1 + i) % SkillCycle.Num();
        const FAutoSkillInfo&amp; SkillInfo = SkillCycle[CurrentIndex];

        // 2. 스킬 사용 조건(쿨타임, 비용, 커스텀 조건 등) 확인
        if (IsSkillReady(SkillInfo) &amp;&amp; AreSpecialConditionsMet(SkillInfo.Conditions))
        {
            // 3. 사용할 스킬로 결정하고, 마지막 사용 인덱스를 기억
            SetSkillToUse(SkillInfo.SkillID);
            LastUsedSkillIndex = CurrentIndex;
            return; // 사용할 스킬을 찾았으므로 종료
        }
    }
}
</code></pre>
                    <hr class="my-5">
                    <h3 class="mb-4">스캔 시스템</h3>
                    <p>
                        기존 스캔 시스템의 결합도를 낮추고 확장성을 높이기 위해, 각 모듈의 역할과 책임을 명확히 분리하는 아키텍처 개선을 진행했습니다.
                    </p>
                    <p>
                        - <strong>`CharacterRepository`</strong>: 월드에 존재하는 <strong>모든 캐릭터의 목록을 제공</strong>하는 데이터 소스입니다.<br>
                        - <strong>`ScanComponent`</strong>: <strong>스캔 반경, 최대 스캔 수, 타겟팅 정책</strong> 등 스캔 조건을 직접 설정하고 실행을 요청합니다.<br>
                        - <strong>`ScanModel`</strong>: `ScanComponent`의 요청을 받아, `CharacterRepository`의 목록을 필터링하여 최종 결과를 생성하고 관리합니다.<br>
                    </p>
                    <p>
                        이 구조는 스캔의 조건과 실행이 명확하게 분리되어, 향후 새로운 스캔 기능이 추가되더라도 `ScanModel`이나 `CharacterRepository`의 변경 없이 `ScanComponent`만 수정하여 대응할 수 있는 유연성을 제공합니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>모듈화 및 책임 분리:</strong> 스캔 시스템을 `CharacterRepository`, `ScanComponent`, `ScanModel`로 명확히 분리하여 각 모듈이 고유한 책임만을 갖도록 설계했습니다. 이는 시스템의 결합도를 낮추고 이해하기 쉬운 구조를 만드는 데 기여했습니다.</li>
                            <li><strong>유연한 확장성 확보:</strong> 스캔 조건 설정과 실제 스캔 로직을 분리함으로써, 향후 새로운 스캔 기능이나 정책이 추가되더라도 기존 핵심 로직의 변경 없이 `ScanComponent`만 수정하여 유연하게 대응할 수 있는 확장성을 확보했습니다.</li>
                            <li><strong>데이터 중심 설계:</strong> `CharacterRepository`를 통해 캐릭터 데이터를 중앙에서 관리하고, `ScanModel`이 이 데이터를 활용하여 스캔을 수행하도록 함으로써 데이터의 일관성과 재사용성을 높였습니다.</li>
                        </ul>
                    </p>
                    <pre><code class="language-cpp">// CharacterRepository.h
// 월드에 존재하는 모든 캐릭터의 마스터 목록을 관리
TMap&lt;EScanType, TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;&gt; AllCharactersByType;

// 마스터 목록을 반환하는 Getter
const TMap&lt;EScanType, TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;&gt;&amp; GetMasterCharacterList() const;

// GameMode 이벤트를 받아 마스터 목록을 관리
void OnCharacterSpawned(ABaseCharacter* SpawnedCharacter);
void OnCharacterRemoved(ABaseCharacter* RemovedCharacter);


// ScanComponent.h
// 스캔에 필요한 조건들을 프로퍼티로 직접 관리
UPROPERTY(EditAnywhere)
float ScanRadius = 1500.f;

UPROPERTY(EditAnywhere)
int32 MaxScanCount = 10;

UPROPERTY(EditAnywhere)
TArray&lt;EScanType&gt; ScanPriority; // 타겟팅 정책


// ScanComponent.cpp
// 스캔을 모델에 요청
void UScanComponent::RequestScan()
{
    // 스캔에 필요한 조건들을 설정
    FScanRequest Request;
    Request.ScanCenter = GetOwner()-&gt;GetActorLocation();
    Request.ScanRadius = this-&gt;ScanRadius;
    Request.ScanPriority = this-&gt;ScanPriority; // 컴포넌트가 직접 관리하는 정책 사용
    Request.MaxScanCount = this-&gt;MaxScanCount;

    // ScanModel에 스캔 실행을 요청
    ScanModel-&gt;ExecuteScan(Request);
}


// ScanModel.cpp
// ScanComponent로부터 스캔 요청을 받아 처리
void UScanModel::ExecuteScan(const FScanRequest&amp; Request)
{
    FinalScannedList.Empty();

    // 1. CharacterRepository로부터 마스터 목록을 가져옴
    const TMap&lt;EScanType, TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;&gt;&amp; MasterList = CharacterRepository-&gt;GetMasterCharacterList();

    // 2. 요청받은 정책에 따라 우선순위 목록을 순회
    for (EScanType CurrentType : Request.ScanPriority)
    {
        if (FinalScannedList.Num() &gt;= Request.MaxScanCount) break;

        if (const TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;* CharacterList = MasterList.Find(CurrentType))
        {
            TArray&lt;ABaseCharacter*&gt; ValidCharactersInType;
            // 3. 각 캐릭터가 스캔 조건(거리, 장애물 등)에 맞는지 필터링
            for (const TWeakObjectPtr&lt;ABaseCharacter&gt;&amp; CharacterPtr : *CharacterList)
            {
                if (IsCharacterValidForScan(CharacterPtr.Get(), Request))
                {
                    ValidCharactersInType.Add(CharacterPtr.Get());
                }
            }

            // 4. 같은 타입 내에서 거리순으로 정렬
            ValidCharactersInType.Sort([&amp;Request](const ABaseCharacter&amp; A, const ABaseCharacter&amp; B) {
                float DistA = FVector::DistSquared(A.GetActorLocation(), Request.ScanCenter);
                float DistB = FVector::DistSquared(B.GetActorLocation(), Request.ScanCenter);
                return DistA &lt; DistB;
            });

            // 5. 정렬된 목록을 최종 리스트에 추가 (최대 스캔 수 제한)
            int32 NumToAdd = FMath::Min(ValidCharactersInType.Num(), Request.MaxScanCount - FinalScannedList.Num());
            FinalScannedList.Append(ValidCharactersInType.GetData(), NumToAdd);
        }
    }

    // 6. 최종 목록을 델리게이트로 통지
    if(OnScanCompleted.IsBound())
    {
        OnScanCompleted.Broadcast(FinalScannedList);
    }
}
</code></pre>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Architecture & Efficiency -->
            <section class="resume-section" id="architecture-efficiency">
                <div class="resume-section-content">
                    <h2 class="mb-5">개발 효율성 및 아키텍처 개선</h2>
                    <p class="lead mb-4">
                        유지보수성과 확장성을 고려한 아키텍처를 설계하고, 반복적인 작업을 자동화하여 팀 전체의 개발 효율성을 높이는 데 기여했습니다.
                    </p>
                    
                    <hr class="my-5">

                    <h3 class="mb-4">MVVM 아키텍처 도입</h3>
                    <p>
                        UI와 데이터 로직의 강한 결합 문제를 해결하기 위해 <strong>MVVM(Model-View-ViewModel) 아키텍처</strong>를 도입했습니다.
                        데이터(Model)와 시각적 표현(View)을 분리하고, 그 사이를 ViewModel이 중개하여 데이터 바인딩을 통해 UI가 자동으로 업데이트되도록 설계했습니다.
                        이를 통해 UI 갱신 코드를 직접 작성할 필요가 없어졌고, 개발자는 데이터 관리 로직에만 집중할 수 있어 <strong>개발 생산성과 코드 안정성</strong>이 크게 향상되었습니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>아키텍처 선택의 중요성과 실질적 적용:</strong> UI와 데이터 로직의 강한 결합 문제를 해결하고 디자이너-개발자 간 협업 효율성을 극대화하기 위해 MVVM 아키텍처를 도입했습니다. 이 과정에서 단순히 패턴을 적용하는 것을 넘어, 과도한 바인딩으로 인한 성능 저하를 방지하기 위한 객체 생명 주기 관리 및 메모리 최적화에 깊이 고민하며 안정적인 시스템 구축에 집중했습니다.</li>
                        </ul>
                    </p>
                    <p class="mt-4">
                        아래는 ViewModel의 데이터가 변경되었을 때, <code>UE_MVVM_SET_PROPERTY_VALUE</code> 매크로를 통해 UI에 자동으로 변경사항을 전파하는 실제 구현 예시입니다.
                        이 코드는 데이터 변경 로직과 UI 업데이트를 분리하여, 아키텍처의 핵심 장점을 보여줍니다.
                    </p>
                    <pre><code class="language-cpp">// HUD ViewModel에서 플레이어 HP가 변경될 때, 바인딩된 UI에 자동으로 알리는 예시
void UHUDViewModel::SetPlayerHP(float NewHP)
{
    // UE_MVVM_SET_PROPERTY_VALUE 매크로를 호출해
    // PlayerHP 값을 변경하고, UI에 변경 사항을 자동으로 전파합니다.
    UE_MVVM_SET_PROPERTY_VALUE(PlayerHP, NewHP);
}</code></pre>

                    <div class="text-center my-4">
                        <figure class="figure mt-4" style="max-width: 60%;">
                            <img src="/projects/projectR/image/MVVM.png" class="figure-img img-fluid rounded" alt="MVVM">
                            <figcaption class="figure-caption text-center">Model, View, ViewModel 간의 데이터 흐름과 상호작용을 보여주는 다이어그램</figcaption>
                        </figure>
                    </div>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">순환형 퀵슬롯 (Looping Quick Slot)</h3>
                    <p>
                        한정된 화면 공간에 많은 스킬을 배치하기 위해, 좌우로 무한히 순환하는 퀵슬롯 UI를 구현했습니다. 일반적인 리스트뷰 위젯을 커스터마이징하여 리스트의 양 끝에 아이템을 동적으로 복제하고 스크롤 위치를 조정하는 방식으로, 사용자에게 끊김 없는 스크롤 경험을 제공합니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>사용자 경험과 성능의 균형:</strong> 한정된 공간에서 끊김 없는 순환 스크롤 경험을 제공하기 위해, 단순히 리스트뷰를 반복시키는 것을 넘어 스크롤 오프셋 조절과 아이템 복제 전략을 통해 '무한 순환'의 착시 효과를 구현했습니다. 이 과정에서 발생할 수 있는 스크롤 성능 저하를 최소화하기 위해, 불필요한 UI 요소의 생성 및 갱신을 줄이는 방식에 집중하여 사용자 경험과 성능 최적화라는 두 마리 토끼를 잡는 데 집중했습니다.</li>
                        </ul>
                    </p>
                    <div class="text-center my-4">
                        <figure class="figure mt-4" style="max-width: 60%;">
                            <img src="/projects/projectR/image/LoopListView.svg" class="figure-img img-fluid rounded" alt="순환형 퀵슬롯 다이어그램">
                            <figcaption class="figure-caption text-center">스크롤 이벤트에 따른 위치 동기화 과정을 보여주는 플로우차트</figcaption>
                        </figure>
                    </div>

                    <hr class="my-5">
                    <h3 class="mb-4">AI를 활용한 반복 작업 자동화</h3>
                    <p><strong><i class="fas fa-exclamation-triangle text-warning"></i> 문제점:</strong> 서버 패킷 연결, 데이터 테이블 구조 생성 등 단순하고 반복적인 작업에 개발자의 시간이 많이 소모되었습니다.</p>
                    <p><strong><i class="fas fa-wrench text-primary"></i> 해결:</strong> AI(ChatGPT)를 활용하여 관련 코드를 자동으로 생성하는 스크립트 도구를 개발하고 팀에 공유했습니다.</p>
                    <p><strong><i class="fas fa-check-circle text-success"></i> 결과:</strong> 관련 작업 시간을 <strong>50% 이상 단축</strong>하고, 수작업으로 인해 발생하던 잠재적인 오류를 줄여 개발 안정성을 높였습니다.</p>
                    <p><strong><i class="fas fa-rocket text-info"></i> 개선점:</strong> 현재는 외부 API(ChatGPT)를 사용하고 있어 소스 코드 유출 등 보안에 민감한 정보가 포함될 경우 사용하기 꺼려진다는 한계가 있습니다. 향후에는 Ollama와 같은 도구를 활용해 오픈소스 LLM(GPT-OSS 등)을 로컬 환경에 구축하여, 보안이 중요한 프로젝트에서도 안심하고 사용할 수 있는 코드 생성 시스템으로 발전시키는 것을 고려하고 있습니다.</p>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Optimization & Stability -->
            <section class="resume-section" id="optimization-stability">
                <div class="resume-section-content">
                    <h2 class="mb-5">게임 안정성 및 최적화 기여</h2>
                    <p class="lead mb-4">
                        지속적인 프로파일링과 코드 개선을 통해 안정적인 게임 플레이 환경을 제공하고, 부하가 많이 발생하는 시스템의 성능을 최적화했습니다.
                    </p>
                    <hr class="my-5">

                    <h3 class="mb-4">메모리 관리 개선</h3>
                    <p><strong><i class="fas fa-exclamation-triangle text-warning"></i> 문제점:</strong> 장시간 플레이 시 프레임이 저하되고 특정 상황에서 크래시가 발생하는 문제가 있었습니다.</p>
                    <p>
                        <strong><i class="fas fa-wrench text-primary"></i>해결:</strong> Unreal Insights와 같은 전문 프로파일링 툴과, <code>obj list</code> 등 언리얼 엔진의 콘솔 명령어를 함께 사용하여 메모리 누수의 원인을 다각도로 추적했습니다.
                        이 과정에서 삭제되어야 할 위젯이 다른 오브젝트에서 계속 참조하고 있거나, 몬스터가 죽어 화면에서는 사라졌지만 월드에서 액터가 삭제되지 않고 남아있는 등의 여러 문제점을 발견했습니다.
                        또한, 데미지를 표시하는 액터가 계속 월드에 쌓이는 현상, 데이터 테이블 로딩 방식의 결함으로 인해 짧은 프레임 내에 너무 많은 UObject가 생성되어 크래시를 유발하는 문제 등을 찾아내고 해결했습니다.
                        순환 참조를 유발하는 UObject의 소유권 문제는 <code>TWeakObjectPtr</code>를 사용해 방지하고, 근본적으로는 액터와 위젯의 생명 주기를 명확하게 관리하여 메모리 누수를 방지했습니다.
                    </p>
                    <p><strong><i class="fas fa-check-circle text-success"></i> 결과:</strong> 메모리 사용량을 안정시키고 관련 크래시 발생률을 <strong>90% 이상 감소</strong>시켜 게임의 안정성을 크게 향상시켰습니다.</p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>체계적인 접근의 중요성:</strong> 눈에 보이는 현상 해결을 넘어, 프로파일링 데이터에 기반해 근본 원인을 찾는 체계적인 접근이 중요했습니다. 이를 통해 언리얼 오브젝트의 생명주기를 명확히 관리하고, 순환 참조를 방지하는 메모리 패턴(<code>TWeakObjectPtr</code> 등)을 적용하는 것이 안정적인 게임의 핵심임을 깨달았습니다.</li>
                        </ul>
                    </p>
                    <hr class="my-5">
                    <h3 class="mb-4">미니맵 최적화</h3>
                    <p>
                        수많은 게임 객체가 존재하는 대규모 MMORPG 환경에서, 미니맵 아이콘의 불필요한 반복 계산은 성능 저하의 주요 원인이었습니다. 저는 '객체의 변화가 있을 때만 해당 아이콘을 업데이트한다'는 이벤트 기반 최적화 원칙을 세우고, 이 원칙을 통해 CPU 부하를 획기적으로 줄이는 것을 최우선 과제로 삼았습니다.
                        이를 위해 미니맵은 매 프레임 모든 아이콘의 위치를 업데이트하는 방식 대신, 객체의 <strong>이동 이벤트가 발생할 때만</strong> 해당 아이콘의 위치를 업데이트하는 이벤트 기반 방식으로 변경하여 불필요한 연산을 제거하고 CPU 사용량을 크게 줄여 프레임 안정성을 확보했습니다.
                        아래 코드는 최적화의 핵심 로직으로, 위치가 변경된 오브젝트의 아이콘만 선택적으로 업데이트하여 시스템 부하를 최소화하는 방법을 보여줍니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>성능 병목의 근본 원인 분석 및 패턴화:</strong> 문제 해결의 핵심은 Tick 기반의 비효율적 폴링 구조를 이벤트 기반 방식으로 전환하는 '구조적 개선'에 있었습니다.
                                이 경험은 단순히 미니맵의 CPU 부하를 줄이는 것을 넘어, '이벤트 기반 최적화'라는 설계 패턴을 다른 시스템에도 적용할 수 있도록 재정립했다는 점에서 큰 의미가 있었습니다.
                            </li>
                        </ul>
                    </p>
                    <pre><code class="language-cpp">// 미니맵에서 위치가 변경된 오브젝트만 선별하여 아이콘을 업데이트하는 로직
void UMiniMapViewModel::OnUpdateLocationUIDList(const FMiniMapUpdateLocationUIDListData&amp; UpdateList)
{
    // 위치가 변경된 오브젝트 리스트를 순회
    for (const TPair&lt;int64, FVector&gt;&amp; Pair : UpdateList.UpdateLocationUIDList)
    {
        // 해당 오브젝트의 아이콘을 찾거나, 없다면 새로 생성
        if (UUW_MiniMapObjectIcon* UnitIcon = GetOrCreateIcon(Pair.Key))
        {
            // 아이콘의 위치만 새로 업데이트 (전체 다시 그리기 방지)
            UnitIcon-&gt;UpdatePosition(Pair.Value);
        }
    }
}</code></pre>
                     <div class="text-center my-4">
                        <figure class="figure mt-3 w-75">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 350" class="figure-img img-fluid rounded" alt="미니맵 최적화 전후 비교 다이어그램">
                                <style>
                                    .title { font-family: 'Muli', sans-serif; font-size: 20px; font-weight: bold; text-anchor: middle; fill: #343a40; }
                                    .box { fill: #f8f9fa; stroke: #6c757d; stroke-width: 2; }
                                    .box-text { font-family: 'Muli', sans-serif; font-size: 16px; text-anchor: middle; fill: #212529; }
                                    .arrow { fill: #6c757d; }
                                    .label { font-family: 'Muli', sans-serif; font-size: 14px; text-anchor: middle; }
                                    .bad { fill: #dc3545; }
                                    .good { fill: #28a745; }
                                </style>

                                <!-- 기존 방식 -->
                                <text x="200" y="40" class="title">기존 방식 (Tick 기반)</text>
                                <rect x="100" y="80" width="200" height="50" rx="10" class="box"/>
                                <text x="200" y="110" class="box-text">Every Frame (Tick)</text>
                                
                                <path d="M 200 130 L 200 155" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="75" y="160" width="250" height="50" rx="10" class="box"/>
                                <text x="200" y="190" class="box-text">모든 오브젝트 순회</text>

                                <path d="M 200 210 L 200 235" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="75" y="240" width="250" height="50" rx="10" class="box"/>
                                <text x="200" y="270" class="box-text">모든 아이콘 위치 업데이트</text>

                                <text x="200" y="320" class="label bad">CPU 부하 높음</text>

                                <!-- 개선된 방식 -->
                                <text x="600" y="40" class="title">개선된 방식 (이벤트 기반)</text>
                                <rect x="500" y="80" width="200" height="50" rx="10" class="box"/>
                                <text x="600" y="110" class="box-text">오브젝트 이동</text>

                                <path d="M 600 130 L 600 155" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="500" y="160" width="200" height="50" rx="10" class="box"/>
                                <text x="600" y="190" class="box-text">이벤트 발생</text>

                                <path d="M 600 210 L 600 235" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="475" y="240" width="250" height="50" rx="10" class="box"/>
                                <text x="600" y="270" class="box-text">해당 아이콘만 위치 업데이트</text>

                                <text x="600" y="320" class="label good">CPU 부하 낮음</text>

                                <defs>
                                    <marker id="arrowhead" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#6c757d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <figcaption class="figure-caption text-center">기존 Tick 기반 방식과 개선된 이벤트 기반 방식의 데이터 처리 흐름 비교</figcaption>
                        </figure>
                    </div>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Content Implementation -->
            <section class="resume-section" id="content-implementation">
                <div class="resume-section-content">
                    <h2 class="mb-5">다양한 콘텐츠 시스템 구현</h2>
                    <p class="lead mb-4">
                        MMORPG의 핵심 재미를 구성하는 다양한 시스템과 콘텐츠를 개발하여 게임의 깊이를 더했습니다.
                    </p>
                    <hr class="my-5">

                    <h3 class="mb-4">통합 맵 시스템</h3>
                    <p>
                        플레이어의 원활한 게임 플레이를 돕기 위해 월드맵, 필드맵, 미니맵 세 종류의 맵을 개발했습니다. 각 맵의 이동 및 마우스 커서 위치를 중심으로 한 확대/축소 등 공통 상호작용은 <code>UMapInteractionViewModel</code>을 통해 일관되게 관리되며, 각 맵의 특성에 맞는 뷰모델(<code>WorldMapViewModel</code>, <code>FieldMapViewModel</code>, <code>MiniMapViewModel</code>)이 이를 활용합니다.
                        미니맵에는 퀘스트, 파티, 수배 상태 등 다양한 정보가 아이콘에 실시간으로 표시되며, 플레이어에게 필요한 정보를 즉각적으로 제공합니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li>
                                <strong>공통 기능 분리를 통한 재사용성 확보:</strong> 월드맵, 필드맵, 미니맵에서 모두 사용되는 이동, 확대/축소 같은 공통 기능을 <code>UMapInteractionViewModel</code>이라는 하나의 클래스에서 처리하도록 묶었습니다.
                                각 맵은 이 공통 클래스를 가져다 쓰는 방식으로 구현하여, 동일한 코드를 반복해서 작성할 필요 없이 유지보수가 용이한 구조로 작업하고자 했습니다.
                            </li>
                        </ul>
                    </p>
                    <p class="mt-4">
                        아래 다이어그램은 각 맵 뷰모델이 공통 상호작용 로직을 담당하는 <code>UMapInteractionViewModel</code> 인스턴스를 개별적으로 소유하여 활용하는 구조를 보여줍니다. 이를 통해 각 맵은 독립적으로 상호작용 기능을 사용하면서도, 필요에 따라 자신만의 특화된 로직을 추가할 수 있어 유연하고 확장 가능한 아키텍처를 제공합니다.
                    </p>
                    <div class="text-center my-3">
                        <figure class="figure w-75">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 180" class="figure-img img-fluid rounded" alt="통합 맵 시스템 아키텍처 다이어그램">
                                <style>
                                    .box { fill: #f8f9fa; stroke: #6c757d; stroke-width: 2; }
                                    .box-text { font-family: 'Muli', sans-serif; font-size: 16px; text-anchor: middle; fill: #212529; }
                                    .inner-box { fill: #e9ecef; stroke: #adb5bd; stroke-width: 1; }
                                    .inner-box-text { font-family: 'Muli', sans-serif; font-size: 14px; fill: #495057; }
                                    .arrow { fill: #6c757d; }
                                    .label { font-family: 'Muli', sans-serif; font-size: 14px; text-anchor: middle; }
                                </style>

                                <!-- WorldMapViewModel -->
                                <rect x="50" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="150" y="75" class="box-text">WorldMapViewModel</text>
                                <rect x="60" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="70" y="120" class="inner-box-text">UMapInteractionViewModel</text>

                                <!-- FieldMapViewModel -->
                                <rect x="300" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="400" y="75" class="box-text">FieldMapViewModel</text>
                                <rect x="310" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="320" y="120" class="inner-box-text">UMapInteractionViewModel</text>

                                <!-- MiniMapViewModel -->
                                <rect x="550" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="650" y="75" class="box-text">MiniMapViewModel</text>
                                <rect x="560" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="570" y="120" class="inner-box-text">UMapInteractionViewModel</text>
                            </svg>
                            <figcaption class="figure-caption text-center mt-2">통합 맵 시스템 아키텍처: 각 뷰모델이 UMapInteractionViewModel을 소유하는 구조</figcaption>
                        </figure>
                    </div>

                    <hr class="my-5">
                    <h3 class="mb-4">유연하고 확장 가능한 데이터 기반 시스템 설계</h3>
                    <p>
                        복잡한 게임 콘텐츠를 효율적으로 관리하고 유연하게 확장하기 위해 <strong>데이터 기반의 모듈식 시스템</strong>을 설계하고 구현했습니다.
                        각 게임 기능(업적, 레이드, 스케줄 등)을 독립적인 데이터 모델로 분리하고, 모든 로직이 데이터 테이블에 의해 제어되도록 아키텍처를 구축했습니다.
                        이를 통해 기획자는 코드 수정 없이 데이터 조작만으로 콘텐츠를 추가하거나 밸런스를 조정할 수 있게 되어 개발 효율성과 운영 안정성을 크게 높였습니다.
                    </p>
                    <p class="mb-2">
                        <strong>💡 개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li>
                                <strong>관심사의 분리:</strong> 각 게임 시스템을 독립적인 데이터 모델로 설계하여 코드의 의존성을 낮추고 유지보수성을 높였습니다. 예를 들어, 전투 로직은 전투 모델에, 스케줄 로직은 스케줄 모델에 집중되어 있어 특정 기능 수정이 다른 시스템에 미치는 영향을 최소화했습니다.
                            </li>
                            <li>
                                <strong>데이터 기반 설계:</strong> 핵심 로직의 동작을 데이터 테이블에 의해 결정되도록 하여, 기획자가 직접 콘텐츠를 제어하고 빠르게 반복하며 개선할 수 있는 환경을 만들었습니다. 이는 라이브 서비스 환경에서 신속한 대응을 가능하게 했습니다.
                            </li>
                            <li>
                                <strong>확장성:</strong> 새로운 기능이나 콘텐츠가 추가될 때, 기존 코드를 수정하기보다 새로운 모듈(모델, 스케줄러 등)을 추가하여 시스템이 확장되도록 구조를 설계했습니다. 이를 통해 장기적인 프로젝트의 안정성과 개발 속도를 확보하고자 했습니다.
                            </li>
                        </ul>
                    </p>
                    <p class="mt-4">
                        대표적인 예로, 보스 출현이나 던전 오픈 같은 다양한 콘텐츠의 시간을 관리하는 <strong>콘텐츠 스케줄 시스템</strong>이 있습니다.
                        중앙 스케줄 모델이 데이터 테이블에 정의된 정보를 바탕으로 각기 다른 타입의 스케줄러를 동적으로 생성하고 관리합니다.
                        덕분에 새로운 유형의 스케줄이 필요할 때, 코드 변경 없이 데이터 테이블에 새로운 스케줄러 정보를 추가하는 것만으로 간단히 확장할 수 있었습니다.
                    </p>
                    <p class="mt-4">
                        아래는 데이터 테이블의 클래스 정보를 이용해 해당 타입에 맞는 스케줄러를 동적으로 생성하는 시스템의 핵심 로직입니다.
                        이처럼 데이터에 기반해 로직이 결정되는 구조는 시스템 전체의 유연성을 극대화합니다.
                    </p>
                    <pre><code class="language-cpp">// 데이터 테이블에 정의된 정보로 콘텐츠 스케줄러를 생성하는 로직
void UScheduleModel::MakeScheduler(const FContentScheduleRow&amp; ScheduleData)
{
    // 데이터 테이블에서 스케줄러 클래스 정보를 가져옴
    TSubclassOf&lt;UContentSchedulerBase&gt; SchedulerClass = ScheduleData.SchedulerClass.LoadSynchronous();
    if (SchedulerClass)
    {
        // 해당 클래스로 스케줄러 인스턴스를 생성
        UContentSchedulerBase* NewScheduler = NewObject&lt;UContentSchedulerBase&gt;(this, SchedulerClass);
        
        // 생성된 스케줄러를 초기화하고 모델에 등록
        NewScheduler-&gt;Initialize(ScheduleData);
        AddScheduler(ScheduleData.Type, NewScheduler);
    }
}</code></pre>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">주요 인게임 콘텐츠 개발</h3>
                    <p>
                        이 외에도 MMORPG의 핵심적인 재미를 구성하는 다양한 콘텐츠 개발에 참여했습니다.
                        수많은 콘텐츠를 짧은 시간 내에 안정적으로 구현하는 것이 중요했으며, 저는 이를 위해 재사용 가능한 모듈형 컴포넌트와 유연한 데이터 구조 설계를 바탕으로 확장성 있는 콘텐츠 프레임워크를 구축하는 데 집중했습니다
                    </p>
                    <ul>
                        <li class="mb-3"><strong>레이드 던전:</strong> 여러 플레이어가 협력하여 보스를 공략하는 콘텐츠의 기본 구조를 모듈화하여, 향후 다양한 종류의 레이드를 쉽게 추가할 수 있는 기반을 마련했습니다.
                            <p class="mt-3">
                                아래 코드는 모든 던전의 공통 기능을 캡슐화한 <code>BaseDungeonModel</code>과 이를 상속받아 특정 콘텐츠에 맞게 확장하는 <code>BossRaidModel</code>의 예시입니다.
                                공통 기능(제한 시간 관리 등)은 기본 클래스에서 처리하고, 각기 다른 패킷 처리나 실패 조건은 자식 클래스에서 재정의하도록 설계하여 코드의 재사용성과 확장성을 높였습니다.
                            </p>
                            <pre><code class="language-cpp">// 모든 던전의 공통 기능을 정의하는 기본 클래스
class BaseDungeonModel
{
public:
    // 던전 시작 시 공통적으로 제한 시간 타이머를 작동시킴
    virtual void Start()
    {
        CountdownTimer-&gt;OnFinished.AddDynamic(this, &amp;BaseDungeonModel::OnTimeOver);
        CountdownTimer-&gt;Start(DungeonTimeLimit);
    }

protected:
    // 시간이 다 되었을 때 호출될 공통 로직
    virtual void OnTimeOver() 
    {
        // 던전 실패 처리
    } 

    UPROPERTY()
    UCountdownTimer* CountdownTimer; // 시간 제한을 관리하는 오브젝트
};

// 기본 모델을 상속받아, '보스 레이드'에 특화된 시간 만료 로직을 구현
class BossRaidModel : public BaseDungeonModel
{
protected:
    // BaseDungeonModel의 OnTimeOver를 재정의(override)
    virtual void OnTimeOver() override
    {
        // 보스 레이드에 맞는 실패 UI를 띄우고, 추가 보상 로직 등을 처리
        ShowBossRaidFailureUI();
    }
};</code></pre>
                        </li>
                        <li class="mb-3"><strong>배틀 아레나(PVP):</strong> 다른 플레이어와 실력을 겨루는 PVP 콘텐츠입니다. 시간이 지남에 따라 안전 구역이 좁혀지는 배틀그라운드의 자기장과 같은 시스템을 도입하여 전투의 긴장감을 높였습니다.
                            또한, 특정 아이템이 맵에 생성되는 이벤트 등을 처리할 수 있는 유연한 구조로 설계하여 다양한 전략적 변수를 창출할 수 있도록 했습니다.
                            <p class="mt-3">
                                아래는 배틀 아레나의 핵심 게임플레이 로직을 관리하는 이벤트 처리 시스템의 일부입니다.
                                서버로부터 받은 이벤트 타입에 따라 안전 구역(자기장)을 조절하거나, 맵에 아이템을 생성하는 등 다양한 게임 이벤트를 추가할 수 있도록 설계했습니다.
                            </p>
                            <pre><code class="language-cpp">// 배틀 아레나에서 발생하는 이벤트를 타입에 따라 처리하는 로직
void UBattleArenaPlaySystem::ProcessArenaEvent(const FArenaEvent&amp; EventData)
{
    EArenaEventType EventType = EventData.Type;

    switch (EventType)
    {
        case EArenaEventType::ShrinkSafeZone:
            // 다음 안전 구역의 위치와 크기를 계산하여 적용
            UpdateSafeZone(EventData.ZoneInfo);
            break;
        case EArenaEventType::SpawnSpecialItem:
            // 지정된 위치에 특별 아이템 생성
            SpawnItemOnMap(EventData.ItemInfo, EventData.SpawnLocation);
            break;
        // ... 기타 이벤트 처리 ...
    }
}</code></pre>
                        </li>
                        <li class="mb-3"><strong>업적 및 시즌패스:</strong> 플레이어의 성취감을 높이고 지속적인 동기를 부여하는 업적 시스템과 시즌패스 보상 시스템을 구현했습니다.</li>
                        <li class="mb-3"><strong>우편 및 소환 상점:</strong> 게임 내 재화나 아이템을 주고받는 우편 시스템과, 재화를 통한 뽑기를 제공하는 소환 상점 시스템을 개발하여 게임의 경제 시스템을 뒷받침했습니다.</li>
                        <li class="mb-3"><strong>절전 모드:</strong> 캐릭터 상태와 획득 아이템 등 핵심 정보는 실시간으로 표시하는 절전 모드를 구현했습니다.</li>
                        <li><strong>마을 내 편의 기능:</strong> 마을 내 UI에서 NPC 리스트를 제공하여 선택 시 해당 위치로 자동 이동할 수 있는 기능을 개발하여, 플레이어가 넓은 마을에서 원하는 NPC를 쉽게 찾을 수 있도록 했습니다.</li>
                    </ul>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Growth -->
            <section class="resume-section" id="growth">
                <div class="resume-section-content">
                    <h2 class="mb-5">성장</h2>
                    <h3 class="mb-4">Unreal Engine 5 기반 대규모 프로젝트 경험</h3>
                    <p>대규모 다중 사용자 환경(MMO)에서 실시간 렌더링, 크로스플랫폼(PC/모바일) 대응 등 고난도의 기술 과제를 해결하며 언리얼 엔진에 대한 깊은 이해를 갖추게 되었습니다. 특히 MVVM 아키텍처, 오브젝트 풀링, 이벤트 기반 시스템 등 복잡한 시스템을 설계하고 구현하는 과정에서 언리얼 엔진의 다양한 기능을 심도 있게 활용하는 역량을 키웠습니다.</p>
                    <hr class="my-5">

                    <h3 class="mb-4">협업을 통한 시스템 설계 및 개선 역량 강화</h3>
                    <p>팀원들과 긴밀하게 협력하며 레이드 시스템, 보스 스케줄 등 복잡한 콘텐츠의 구조를 설계했습니다. 특히 <code>UAttackProcessor</code>의 상태 머신 패턴 도입, <code>UAutoCombatProcessor</code> 및 <code>UAutoSkillComponent</code>의 지능형 로직 구현 등 모듈화되고 재사용 가능한 구조로 시스템을 개선하며 팀 전체의 개발 생산성 향상에 기여했습니다. 이 과정에서 요구사항 분석, 설계 논의, 코드 리뷰를 통해 협업 능력을 크게 향상시켰습니다.</p>
                    <hr class="my-5">

                    <h3 class="mb-4">디버깅 및 성능 개선 역량 강화</h3>
                    <p>미니맵 최적화 과정에서 발생한 불필요한 연산 제거, 메모리 누수 및 댕글링 포인터와 같은 찾아내기 어려운 버그들을 Unreal Insights와 같은 전문 프로파일링 툴을 활용하여 해결하며 실전 디버깅 역량을 키웠습니다. 또한, 오브젝트 풀링 및 효율적인 리소스 관리(<code>TSoftObjectPtr</code>)를 통해 안정적인 게임 플레이 환경을 제공하는 성능 최적화 능력을 갖추게 되었습니다.</p>
                </div>
            </section>
        </div>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>  
        <!-- Core theme JS-->
        <script src="/js/scripts.js"></script>
    </body>
</html>