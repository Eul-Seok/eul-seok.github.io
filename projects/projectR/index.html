<!DOCTYPE html>
<html lang="ko">
    <head>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-BV65H1BYK0"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-BV65H1BYK0');
        </script>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="프로젝트R에 대한 기여도를 상세하게 기술한 포트폴리오입니다." />
        <meta name="author" content="홍을석" />
        <title>프로젝트R</title>
        <link rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="../../css/styles.css?v=20250825_1" rel="stylesheet" />
        
        <link rel="stylesheet" href="../../highlight/styles/vs.min.css">
        <script src="../../highlight/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand" href="../../index.html">
                <span class="d-block d-lg-none">홈</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="../../assets/img/profile.jpg" alt="프로필 사진" /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link" href="../../index.html">홈</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#about">게임 소개</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#contributions">주요 기여</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#combat-system">전투 시스템</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#architecture-efficiency">아키텍처 개선</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#optimization-stability">최적화</a></li>
                    <li class="nav-item nested"><a class="nav-link js-scroll-trigger" href="#content-implementation">콘텐츠 구현</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#growth">성장</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <!-- About-->
            <section class="resume-section" id="about">
                <div class="resume-section-content">
                    <h1 class="mb-0">
                        Project R
                    </h1>
                    <div class="subheading mb-2">
                        BluePotion Games
                    </div>
                     <div class="row align-items-center">
                        <div class="col-lg-7 mb-lg-0 mb-4 pe-lg-4">
                            <div class="ratio ratio-16x9">
                                <iframe src="https://www.youtube.com/embed/slBGNvYOWIA" title="Project R Video" allowfullscreen></iframe>
                            </div>
                        </div>
                        <div class="col-lg-5 ps-lg-4">
                            <div>
                                <p class="mb-2"><strong>Released:</strong> 미정</p>
                                <p class="mb-2"><strong>Developer:</strong> BluePotion Games</p>
                                <p class="mb-2"><strong>Platforms:</strong> PC, Android</p>
                                <p class="mb-2"><strong>Skill focus:</strong> 전투 시스템, 콘텐츠 구현, UI/UX, 아키텍처 설계, 최적화</p>
                                <p class="mb-2"><strong>Time spent on project:</strong> 2023.09 ~ 2025.09</p>
                                <p class="mb-0"><strong>Language & Engine:</strong> C++, Unreal Engine 5</p>
                            </div>
                        </div>
                    </div>
                    <p class="mt-4">
                        본 프로젝트는 <strong>크로스플랫폼(PC 및 모바일)</strong> 기반의 <strong>리니지 라이크 스타일의 대규모 MMORPG</strong>로, C++과 Unreal Engine 5를 활용해 제작되었습니다.
                        저는 2023년 9월부터 클라이언트 개발팀의 팀원으로 합류했으며, 2년간 <strong>전투 시스템, UI/UX, 시스템 아키텍처 설계 및 최적화</strong> 등 게임의 핵심적인 부분들을 담당하였습니다.<br><br>
                        <strong>World Partition, Gameplay Ability System(GAS)</strong> 등 언리얼 엔진 5의 최신 기술들이 활용되었으며, UI 개발에는 <strong>MVVM(Model-View-ViewModel) 아키텍처</strong>를 도입하여 코드의 재사용성과 유지보수성을 높였습니다.
                        현재 출시 미정인 비공개 프로젝트라 주요 내용은 텍스트 중심으로 구성했습니다.
                    </p>
                </div>
            </section>
            <hr class="m-0" />
            
            <!-- Contributions -->
            <section class="resume-section" id="contributions">
                <div class="resume-section-content">
                    <h2 class="mb-5">나의 주요 기여</h2>
                    <p class="lead mb-5">
                        저는 프로젝트 R 개발과정에서 다음과 같은 기여를 통해 게임의 완성도와 개발 효율성을 높였습니다.
                    </p>
                    <div class="accordion" id="experienceAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                                    <strong>전투 시스템 설계 및 개선</strong>
                                </button>
                            </h2>
                            <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne">
                                <div class="accordion-body">
                                    <li>State Machine 패턴 적용으로 <strong>전투 프로세스 구조 재편 및 안정성 강화</strong></li>
                                    <li><strong>자동 전투 시스템</strong> 직접 개발로 편의성 및 몰입도 향상</li>
                                    <li>콤보 스킬, 퀵슬롯, 스캔 시스템 구현으로 전투 핵심 기능 고도화</li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="true" aria-controls="collapseTwo">
                                    <strong>개발 효율성 및 아키텍처 개선</strong>
                                </button>
                            </h2>
                            <div id="collapseTwo" class="accordion-collapse collapse show" aria-labelledby="headingTwo">
                                <div class="accordion-body">
                                    <li>MVVM 구조·공통 UI 컴포넌트 도입으로 코드 재사용 및 <strong>생산성 향상</strong></li>
                                    <li>AI 스크립트 자동 생성 도구로 서버 패킷·데이터 <strong>작업 시간 50% 단축</strong></li>
                                    <li>콘텐츠 스케줄 관리 시스템 구축으로 운영 <strong>안정성 확보</strong></li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="true" aria-controls="collapseThree">
                                    <strong>게임 안정성 및 최적화 기여</strong>
                                </button>
                            </h2>
                            <div id="collapseThree" class="accordion-collapse collapse show" aria-labelledby="headingThree">
                                <div class="accordion-body">
                                    <li>메모리 누수·댕글링 포인터 버그 수정으로 <strong>안정성·성능 대폭 개선</strong></li>
                                    <li>미니맵 <strong>이벤트 기반 업데이트 전환</strong>으로 <strong>CPU 부하 개선</strong></li>
                                </div>
                            </div>
                        </div>
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="true" aria-controls="collapseFour">
                                    <strong>다양한 콘텐츠 시스템 구현</strong>
                                </button>
                            </h2>
                            <div id="collapseFour" class="accordion-collapse collapse show" aria-labelledby="headingFour">
                                <div class="accordion-body">
                                    <li>월드맵·필드맵·미니맵 UI 개발로 시각 퀄리티 및 UX 개선</li>
                                    <li>레이드 던전 콘텐츠 구조 모듈화로 <strong>재사용성 극대화</strong></li>
                                    <li>결투·업적·시즌패스·우편·소환 상점 등 <strong>방대한 콘텐츠 개발</strong></li>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Combat System -->
            <section class="resume-section" id="combat-system">
                <div class="resume-section-content">
                    <h2 class="mb-5">전투 시스템 설계 및 개선</h2>
                    <p class="lead">
                        프로젝트 R의 전투 시스템은 복잡한 상황에서도 전투 흐름을 명확하게 분리하고 예외 상황을 안정적으로 처리할 수 있도록 <strong>상태 머신(State Machine) 패턴</strong>을 기반으로 설계하였습니다.<br>
                        또한, 자동 전투 로직(<code>UAutoCombatProcessor</code>)과 스킬 컴포넌트(<code>UAutoSkillComponent</code>)는 <strong>기능 간 결합도를 낮추고 독립적으로 동작할 수 있도록 모듈화</strong>하여 다양한 콘텐츠에 유연하게 적용 가능한 구조로 구현했습니다.
                    </p>
                    <hr class="my-5">

                    <h3 class="mb-4">전투 프로세스 구조 개선</h3>
                    <p><strong class="text-navy-bold">문제점:</strong> 기존 전투 로직은 여러 조건 분기(if/else)가 중첩된 구조로 인해, 기능 추가나 수정 시 로직이 꼬이는 문제가 자주 발생했습니다. 특히 상태 간 책임이 불분명하여 디버깅과 유지보수가 어려웠습니다.</p>
                    <p><strong class="text-navy-bold">해결:</strong> 상태 머신 패턴을 도입해 전투 프로세스를 `추적`, `회전`, `공격 대기`, `공격 가능` 등 명확한 상태로 분리하고, 각 상태의 전환 조건을 명확하게 정의했습니다. 이를 통해 각 상태는 자신의 책임에만 집중할 수 있게 되었고, 로직의 복잡도는 크게 낮아졌습니다.</p>
                    <p><strong class="text-navy-bold">성과:</strong> 버그 발생률이 감소하고 코드의 가독성과 유지보수성이 향상되어, 새로운 전투 기능을 안정적으로 추가할 수 있는 기반을 마련했습니다.</p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>단일 책임 원칙:</strong> 공격 가능 여부 판단(거리, 각도 등)과 실제 공격 실행 로직을 분리하여, 각 상태가 하나의 책임만 갖도록 설계했습니다.</li>
                            <li><strong>확장성:</strong> 새로운 공격 패턴이나 조건을 추가할 때 기존 상태에 영향을 주지 않고, 해당 상태에만 로직을 추가할 수 있도록 구조화했습니다.</li>
                            <li><strong>명확한 역할 분담:</strong> <code>AttackProcessor</code>는 공격 가능 상태를 판단하고, <code>PlayerController</code>는 실제 공격 실행(서버에 스킬 사용 요청)을 담당하여 각 모듈의 책임을 명확히 분리했습니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5">핵심 구현 코드</div>
                    <pre><code class="language-cpp">// 새로운 공격 상태로 변경하고, 이 변경을 다른 시스템에 알리는(Broadcast) 핵심 로직
void UAttackProcessor::SetAttackState(EAttackState NewState)
{
    if (CurrentState == NewState) return;

    EAttackState PrevState = CurrentState;
    CurrentState = NewState;

    // 상태에 따른 로직 분기 처리
    switch (CurrentState)
    {
        case EAttackState::Trace:   HandleTraceState();   break;
        case EAttackState::Rotate:  HandleRotateState();  break;
        case EAttackState::Attack:  HandleAttackState();  break;
    }

    // 상태 변경을 Delegate로 Broadcast하여,
    // 이벤트를 구독하는 다른 객체(플레이어 컨트롤러, UI 등)에 통지합니다.
    if(OnAttackStateChanged.IsBound())
    {
        OnAttackStateChanged.Broadcast(PrevState, CurrentState);
    }
}
</code></pre>
                    <p>
                        이 구조는 상태 변경 시 관련 로직만 실행되며, 델리게이트를 통해 UI나 컨트롤러 등 다른 시스템에 상태 변화를 통지함으로써 결합도를 낮추고 확장성을 높였습니다.
                    </p>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">자동 전투 및 스킬 시스템</h3>
                    <div class="subheading mb-1">기능 개요</div>
                    <p>
                        단순히 가장 가까운 적을 공격하는 수준을 넘어, <strong>자동 반격, 우선 순위 대상 지정 등</strong> 다양한 전략 옵션을 제공하는 <strong>자동 전투 시스템을 직접 설계 및 구현했습니다.</strong> 이를 통해 플레이어가 수동 조작 없이도 전략적인 전투를 펼칠 수 있도록 지원했습니다.
                        또한, 플레이어가 자동 전투 시 사용할 스킬의 순서와 조건을 직접 설정할 수 있는 <strong>커스터마이징 가능한 자동 스킬 시스템</strong>을 개발하여, 개인의 전투 스타일과 전략을 반영할 수 있는 유연한 구조를 구현했습니다.
                        스킬 사용 로직은 서버와의 긴밀한 통신을 통해 처리되며, 클라이언트는 스킬 사용의 유효성을 검사하고 대상 선정 후 서버에 요청을 보내는 구조로 설계하여 정확성과 안정성을 확보했습니다.
                    </p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>컴포넌트 기반 아키텍처:</strong> 자동 전투, 스킬, 스캔 등 핵심 기능을 독립적인 컴포넌트로 분리하여 재사용성과 유지보수성을 높였습니다. 각 컴포넌트는 단일 책임 원칙(SRP)을 따르며, 높은 응집도와 낮은 결합도를 유지하도록 설계했습니다.</li>
                            <li><strong>유연한 확장성:</strong> 새로운 스킬 조건이나 전투 전략을 추가할 때 기존 로직에 영향을 주지 않고, 해당 컴포넌트만 수정하여 대응할 수 있도록 구조화했습니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5">핵심 로직 예시</div>
                    <pre><code class="language-cpp">// 자동 전투 시, 정해진 순서에 따라 다음 스킬을 찾는 로직
void UAutoSkillComponent::FindNextSkillToUse()
{
    // SkillCycle 배열을 총 1번만 순회하도록
    for (int32 i = 0; i &lt; SkillCycle.Num(); ++i)
    {
        // 1. 마지막에 사용한 스킬의 다음 인덱스부터 순회 시작
        int32 CurrentIndex = (LastUsedSkillIndex + 1 + i) % SkillCycle.Num();
        const FAutoSkillInfo&amp; SkillInfo = SkillCycle[CurrentIndex];

        // 2. 스킬 사용 조건(쿨타임, 비용, 커스텀 조건 등) 확인
        if (IsSkillReady(SkillInfo) &amp;&amp; AreSpecialConditionsMet(SkillInfo.Conditions))
        {
            // 3. 사용할 스킬로 결정하고, 마지막 사용 인덱스를 기억
            SetSkillToUse(SkillInfo.SkillID);
            LastUsedSkillIndex = CurrentIndex;
            return; // 사용할 스킬을 찾았으므로 종료
        }
    }
}
</code></pre>
                    <p>
                        이 로직은 플레이어가 설정한 스킬 사이클을 순회하며, 마지막으로 사용한 스킬 이후부터 조건을 검사해 다음 스킬을 결정합니다. 이를 통해 정해진 순서에 따라 지능적으로 스킬을 사용하는 자동화 전투 흐름을 구현했습니다.
                    </p>
                    <hr class="my-5">
                    <h3 class="mb-4">스캔 시스템 아키텍처 개선</h3>
                    <p><strong class="text-navy-bold">문제점:</strong> 초기 스캔 시스템은 조건 설정, 실행 로직, 데이터 접근이 하나의 모듈에 혼재되어 있어 기능 추가 시 전체 구조를 수정해야 하는 높은 결합도를 갖고 있었으며, 이는 유지보수와 확장에 큰 제약이 되었습니다.</p>
                    <p><strong class="text-navy-bold">해결:</strong> 스캔 시스템을 세 가지 핵심 모듈로 분리하여 책임을 명확히 구분했습니다.</p>
                    <table class="table table-bordered mt-3 mb-4">
                        <thead class="thead-light">
                            <tr>
                                <th scope="col" class="text-center" style="width: 30%;">모듈</th>
                                <th scope="col">역할</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="text-center"><strong>CharacterRepository</strong></td>
                                <td>월드 내 모든 캐릭터 목록을 중앙에서 관리하는 데이터 소스</td>
                            </tr>
                            <tr>
                                <td class="text-center"><strong>ScanComponent</strong></td>
                                <td>스캔 반경, 최대 수, 우선순위 정책 등 조건 설정 및 실행 요청 담당</td>
                            </tr>
                            <tr>
                                <td class="text-center"><strong>ScanModel</strong></td>
                                <td>조건에 따라 CharacterRepository의 데이터를 필터링하고 결과 생성</td>
                            </tr>
                        </tbody>
                    </table>
                
                    <p>이 구조는 <strong>조건 설정과 실행 로직을 분리</strong>함으로써, 새로운 스캔 기능이 추가되더라도 <code>ScanComponent</code>만 수정하면 되며, 핵심 로직(<code>ScanModel</code>, <code>CharacterRepository</code>)은 그대로 유지할 수 있어 <strong>확장성과 안정성</strong>을 동시에 확보했습니다.</p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>모듈화 및 책임 분리:</strong> 각 모듈이 단일 책임 원칙을 따르도록 설계하여, 이해하기 쉬운 구조와 낮은 결합도를 달성했습니다.</li>
                            <li><strong>유연한 확장성 확보:</strong> 스캔 조건 설정과 실행 로직을 분리함으로써, 새로운 타겟팅 정책이나 필터링 방식 추가 시 기존 로직에 영향을 주지 않고 독립적으로 확장할 수 있도록 했습니다.</li>
                            <li><strong>데이터 중심 설계:</strong> <code>CharacterRepository</code>를 통해 캐릭터 데이터를 중앙에서 관리하고, <code>ScanModel</code>이 이를 활용하여 스캔을 수행하도록 함으로써 데이터의 일관성과 재사용성을 높였습니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5">핵심 로직 요약</div>
                    <pre><code class="language-cpp">// ScanComponent.cpp
// ScanComponent가 스캔 요청을 생성하고 ScanModel에 전달
void UScanComponent::RequestScan()
{
    // 스캔에 필요한 조건들을 설정
    FScanRequest Request;
    Request.ScanCenter = GetOwner()-&gt;GetActorLocation();
    Request.ScanRadius = this-&gt;ScanRadius;
    Request.ScanPriority = this-&gt;ScanPriority; // 컴포넌트가 직접 관리하는 정책 사용
    Request.MaxScanCount = this-&gt;MaxScanCount;

    // ScanModel에 스캔 실행을 요청
    ScanModel-&gt;ExecuteScan(Request);
}


// ScanModel.cpp
// ScanModel이 요청을 받아 캐릭터 목록을 필터링하고 결과를 생성
void UScanModel::ExecuteScan(const FScanRequest&amp; Request)
{
    FinalScannedList.Empty();

    // CharacterRepository로부터 마스터 목록을 가져옴
    const TMap&lt;EScanType, TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;&gt;&amp; MasterList = CharacterRepository-&gt;GetMasterCharacterList();

    // 요청받은 정책에 따라 우선순위 목록을 순회
    for (EScanType CurrentType : Request.ScanPriority)
    {
        if (FinalScannedList.Num() &gt;= Request.MaxScanCount) break;

        if (const TArray&lt;TWeakObjectPtr&lt;ABaseCharacter&gt;&gt;* CharacterList = MasterList.Find(CurrentType))
        {
            TArray&lt;ABaseCharacter*&gt; ValidCharactersInType;
            // 각 캐릭터가 스캔 조건(거리, 장애물 등)에 맞는지 필터링
            for (const TWeakObjectPtr&lt;ABaseCharacter&gt;&amp; CharacterPtr : *CharacterList)
            {
                if (IsCharacterValidForScan(CharacterPtr.Get(), Request))
                {
                    ValidCharactersInType.Add(CharacterPtr.Get());
                }
            }

            // 같은 타입 내에서 거리순으로 정렬
            ValidCharactersInType.Sort([&amp;Request](const ABaseCharacter&amp; A, const ABaseCharacter&amp; B) {
                float DistA = FVector::DistSquared(A.GetActorLocation(), Request.ScanCenter);
                float DistB = FVector::DistSquared(B.GetActorLocation(), Request.ScanCenter);
                return DistA &lt; DistB;
            });

            // 정렬된 목록을 최종 리스트에 추가 (최대 스캔 수 제한)
            int32 NumToAdd = FMath::Min(ValidCharactersInType.Num(), Request.MaxScanCount - FinalScannedList.Num());
            FinalScannedList.Append(ValidCharactersInType.GetData(), NumToAdd);
        }
    }

    // 최종 목록을 델리게이트로 통지
    if(OnScanCompleted.IsBound())
    {
        OnScanCompleted.Broadcast(FinalScannedList);
    }
}
</code></pre>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Architecture & Efficiency -->
            <section class="resume-section" id="architecture-efficiency">
                <div class="resume-section-content">
                    <h2 class="mb-5">개발 효율성 및 아키텍처 개선</h2>
                    <p class="lead">
                        프로젝트 전반에서 <strong>유지보수성과 확장성을 고려한 아키텍처 설계</strong>를 주도하며, 반복적인 작업을 자동화하고 시스템을 모듈화함으로써 <strong>팀 전체의 개발 효율성 향상</strong>에 기여했습니다.
                    </p>
                    <p class="lead">
                        특히 콘텐츠 스케줄 시스템, 전투 처리 로직, UI 바인딩 구조 등 다양한 영역에서 <strong>재사용 가능한 컴포넌트와 유연한 데이터 구조</strong>를 설계하여 새로운 기능 추가나 변경이 발생하더라도 <strong>최소한의 수정으로 대응 가능한 구조</strong>를 구축했습니다.<br>
                    </p>

                    <hr class="my-5">
                    <h3 class="mb-4">MVVM 아키텍처 도입</h3>
                    <p>
                        <p><strong class="text-navy-bold">문제점:</strong> 초기 UI 시스템은 데이터 로직과 시각적 표현이 강하게 결합되어 있어, UI 변경 시 데이터 처리 로직까지 함께 수정해야 하는 비효율적인 구조였습니다. 이는 디자이너와 개발자 간 협업을 어렵게 만들고, 유지보수 비용을 증가시키는 주요 원인이었습니다.</p>
                        <p><strong class="text-navy-bold">해결:</strong> MVVM(Model-View-ViewModel) 아키텍처를 도입하여 다음과 같은 구조로 재편했습니다.</p>
                        <table class="table table-bordered mt-3 mb-4">
                            <thead class="thead-light">
                                <tr>
                                    <th scope="col" class="text-center" style="width: 20%;">구성 요소</th>
                                    <th scope="col">역할</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="text-center"><strong>Model</strong></td>
                                    <td>게임 상태 및 데이터 관리 (예: HP, 경험치 등)</td>
                                </tr>
                                <tr>
                                    <td class="text-center"><strong>View</strong></td>
                                    <td>UI 위젯 및 시각적 표현</td>
                                </tr>
                                <tr>
                                    <td class="text-center"><strong>ViewModel</strong></td>
                                    <td>Model과 View 사이의 중개자 역할. 데이터 바인딩을 통해 UI 자동 갱신</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>이 구조를 통해 UI 갱신 코드를 직접 작성할 필요 없이, 데이터 변경만으로 UI가 자동으로 업데이트되며, 개발자는 데이터 로직에 집중할 수 있게 되어 <strong>생산성과 안정성</strong>이 크게 향상되었습니다.</p>
                    </p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>아키텍처 선택의 중요성과 실질적 적용:</strong> 단순히 MVVM 패턴을 도입하는 데 그치지 않고, 객체 생명 주기 관리와 메모리 최적화까지 고려하여 과도한 바인딩으로 인한 성능 저하를 방지했습니다.</li>
                            <li><strong>협업 효율성 극대화:</strong> ViewModel을 통해 디자이너는 UI를 자유롭게 수정할 수 있고, 개발자는 데이터 로직에 집중할 수 있어 역할 분담이 명확해지고 협업 속도가 향상되었습니다.</li>
                            <li><strong>유지보수성과 확장성 확보:</strong> UI 변경이 데이터 로직에 영향을 주지 않도록 구조화하여, 새로운 기능 추가나 디자인 변경 시에도 안정적으로 대응할 수 있는 기반을 마련했습니다.</li>
                        </ul>
                    </p>
                    
                    <div class="subheading mt-5">핵심 구현 예시</div>
                    <pre><code class="language-cpp">// HUD ViewModel에서 플레이어 HP가 변경될 때, 바인딩된 UI에 자동으로 알리는 예시
void UHUDViewModel::SetPlayerHP(float NewHP)
{
    // UE_MVVM_SET_PROPERTY_VALUE 매크로를 호출해
    // PlayerHP 값을 변경하고, UI에 변경 사항을 자동으로 전파합니다.
    UE_MVVM_SET_PROPERTY_VALUE(PlayerHP, NewHP);
}</code></pre>
                    <p>
                        이 코드는 <strong>데이터 변경 로직과 UI 업데이트를 명확히 분리</strong>하여, MVVM 아키텍처의 핵심 장점을 보여줍니다.<br>
                        ViewModel은 단순히 데이터 상태를 관리하며, View는 바인딩된 값만을 표시하므로 <strong>결합도가 낮고 테스트가 용이한 구조</strong>를 제공합니다.
                    </p>
                    

                    <div class="text-center my-4">
                        <figure class="figure mt-4" style="max-width: 60%;">
                            <img src="../../projects/projectR/image/MVVM.png" class="figure-img img-fluid rounded" alt="MVVM">
                            <figcaption class="figure-caption text-center">Model, View, ViewModel 간의 데이터 흐름과 상호작용을 보여주는 다이어그램</figcaption>
                        </figure>
                    </div>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">순환형 퀵슬롯 (Looping Quick Slot)</h3>
                    <p>
                        한정된 화면 공간에 많은 스킬을 배치하기 위해, <strong>기존의 ScrollBox 대신 ListView 위젯을 커스터마이징하여</strong> 좌우로 무한히 순환하는 퀵슬롯 UI를 구현했습니다.
                        ScrollBox는 단순한 스크롤 영역만 제공하는 반면, ListView는 <strong>아이템 재사용(Virtualization)과 렌더링 최적화</strong> 기능을 기본적으로 갖추고 있어, 성능과 확장성 측면에서 더 적합하다고 판단했습니다.
                        리스트의 양 끝에 아이템을 동적으로 복제하고, 스크롤 오프셋을 조정하는 방식으로 사용자에게 <strong>끊김 없는 순환 스크롤 경험</strong>을 제공합니다.
                    </p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>사용자 경험과 성능의 균형:</strong> 단순한 반복 스크롤이 아닌, 자연스럽고 끊김 없는 순환 경험을 제공하기 위해 스크롤 오프셋 조절과 아이템 복제 전략을 병행했습니다. 이 과정에서 성능 병목을 방지하기 위해 UI 요소의 생명주기 관리와 최소 갱신 전략을 적용했습니다.</li>
                            <li><strong>UI 최적화 전략:</strong> ListView의 기본적인 가상화 렌더링 구조를 활용하면서, 순환 구조 특유의 착시 효과를 구현하기 위해 커스터마이징을 진행했습니다. 특히 모바일 환경에서의 프레임 드랍을 방지하기 위해 불필요한 UI 생성 최소화에 집중했습니다.</li>
                            <li><strong>확장성과 유지보수성:</strong> 순환 구조는 단순한 스킬 UI에만 국한되지 않고, 아이템 인벤토리, 퀘스트 목록 등 다양한 UI에 재사용 가능하도록 컴포넌트화하여 유지보수성과 확장성을 확보했습니다.</li>
                        </ul>
                    </p>
                    <div class="text-center my-4">
                        <figure class="figure mt-4" style="max-width: 60%;">
                            <img src="../../projects/projectR/image/LoopListView.svg" class="figure-img img-fluid rounded" alt="순환형 퀵슬롯 다이어그램">
                            <figcaption class="figure-caption text-center">스크롤 이벤트에 따른 위치 동기화 과정을 보여주는 플로우차트</figcaption>
                        </figure>
                    </div>

                    <hr class="my-5">
                    <h3 class="mb-4">AI를 활용한 반복 작업 자동화</h3>
                    <p><strong class="text-navy-bold">문제점:</strong> 서버 패킷 연결, 데이터 테이블 구조 생성 등 단순하고 반복적인 작업에 개발자의 시간이 과도하게 소모되었고, 수작업으로 인한 오류 발생 가능성도 존재했습니다.</p>
                    <p><strong class="text-navy-bold">해결:</strong> AI 기반 코드 생성 도구를 개발하여, 서버 패킷 구조 정의 및 핸들러 생성 같은 네트워크 관련 작업은 자동화 스크립트를 통해 빠르게 처리하고, 데이터 테이블 구조 생성은 별도의 템플릿 기반 생성기로 분리하여 콘텐츠 설정 작업의 효율을 높였습니다.</p>
                    <p><strong class="text-navy-bold">결과:</strong> 관련 작업 시간을 <strong>50% 이상 단축</strong>하고, 수작업으로 인해 발생하던 잠재적인 오류를 줄여 개발 안정성을 높였습니다.</p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>도구의 실용성과 팀 적용성:</strong> 단순한 개인 도구가 아닌, 팀 전체가 활용할 수 있는 범용 스크립트로 설계하여 협업 효율을 높였습니다. 예를 들어, 패킷 구조 정의 → 자동 핸들러 생성 → 데이터 테이블 포맷 생성까지 일련의 흐름을 자동화했습니다.</li>
                            <li><strong>보안과 확장성에 대한 고민:</strong> 현재는 외부 API(ChatGPT)를 활용하고 있어, 소스 코드 유출 가능성 등 보안 민감한 프로젝트에서는 사용이 제한됩니다. 이를 해결하기 위해, 향후에는 Ollama와 같은 도구를 활용하여 오픈소스 LLM(GPT-OSS 등)을 로컬 환경에 구축하고, 보안이 중요한 프로젝트에서도 안심하고 사용할 수 있는 내부 전용 코드 생성 시스템으로 발전시키는 것을 고려하고 있습니다.</li>
                        </ul>
                    </p>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Optimization & Stability -->
            <section class="resume-section" id="optimization-stability">
                <div class="resume-section-content">
                    <h2 class="mb-5">게임 안정성 및 최적화 기여</h2>
                    <p class="lead">
                        저는 프로젝트 전반에서 <strong>지속적인 프로파일링과 코드 개선</strong>을 통해 <strong>안정적인 게임 플레이 환경을 제공</strong>하고, <strong>부하가 집중되는 시스템의 성능을 정밀하게 최적화</strong>하는 데 집중했습니다.
                    </p>
                    <p class="lead">
                        특히 Unreal Insights와 같은 전문 프로파일링 툴을 활용하여 <strong>프레임 드랍, 메모리 누수, 댕글링 포인터 등</strong> 실전에서 발생하기 쉬운 문제들을 정확하게 분석하고 해결했으며, 반복적인 연산 제거와 오브젝트 풀링을 통해 <strong>리소스 사용 효율을 극대화</strong>했습니다.
                    </p>

                    <hr class="my-5">
                    <h3 class="mb-4">메모리 관리 개선</h3>
                    <p class = "mb-1"><strong class="text-navy-bold">문제점:</strong> 장시간 플레이 시 프레임 저하가 발생하고, 특정 상황에서는 크래시가 유발되는 문제가 지속적으로 보고되어 왔었습니다. 프로파일링 결과, 다음과 같은 메모리 관리 이슈들이 확인되었습니다.
                        <ul>
                            <li>삭제된 위젯이 다른 오브젝트에서 참조되어 GC 대상에서 제외됨</li>
                            <li>사망한 몬스터가 화면에서는 사라졌지만 월드 내 액터로 남아 있음</li>
                            <li>데미지 표시용 액터가 지속적으로 월드에 누적됨</li>
                            <li>데이터 테이블 로딩 방식의 결함으로 인해 짧은 프레임 내에 과도한 <code>UObject</code> 생성 → 크래시 유발</li>
                        </ul>
                    </p>
                    <p class = "mb-1"><strong class="text-navy-bold">해결:</strong> Unreal Insights, <code>obj list</code> 등 언리얼 엔진의 전문 프로파일링 도구와 콘솔 명령어를 병행하여 다각도로 메모리 누수 원인을 추적하여 개선했습니다.
                        <ul>
                            <li><strong>액터 및 위젯의 생명주기 명확화:</strong> 더 이상 사용하지 않는 순간에 명시적으로 참조 해제</li>
                            <li><strong>순환 참조 방지:</strong> <code>TWeakObjectPtr</code>를 활용하여 GC가 정상 작동하도록 구조 개선</li>
                            <li><strong>데미지 액터 풀링 적용:</strong> 반복 생성 대신 재사용 구조로 변경</li>
                            <li><strong>데이터 테이블 로딩 최적화:</strong> 반복 호출되는 데이터 테이블 접근 방식을 개선하고, 기존의 <code>UObject</code> 인스턴스 생성 방식 대신 구조체 기반으로 데이터를 로딩하여 불필요한 객체 생성을 줄이고 성능을 향상시킴</li>
                        </ul>
                    </p>
                    <p><strong class="text-navy-bold">결과:</strong> 메모리 사용량을 안정시키고, 관련 크래시 발생률을 <strong>90% 이상 감소</strong>시켜 게임의 안정성을 대폭 개선했습니다.</p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>체계적인 접근의 중요성:</strong> 눈에 보이는 현상 해결을 넘어, 프로파일링 데이터에 기반해 근본 원인을 찾는 체계적인 접근이 중요했습니다. 이를 통해 언리얼 오브젝트의 생명주기를 명확히 관리하고, 순환 참조를 방지하는 메모리 패턴(<code>TWeakObjectPtr</code> 등)을 적용하는 것이 안정적인 게임 운영의 핵심임을 깨달았습니다.</li>
                        </ul>
                    </p>
                    <hr class="my-5">
                    <h3 class="mb-4">미니맵 최적화</h3>
                    <p class = "mb-1"><strong class="text-navy-bold">문제점:</strong> 대규모 MMORPG 환경에서는 수많은 게임 객체가 실시간으로 움직이며, 이들의 위치를 매 프레임마다 미니맵에 반영하는 기존 방식은 불필요한 반복 계산을 유발해 CPU 부하와 프레임 저하를 일으킬 잠재적인 위험성이 있었습니다.</p>
                    <p class = "mb-1"><strong class="text-navy-bold">해결:</strong> ‘객체의 변화가 있을 때만 해당 아이콘을 업데이트한다’는 목표를 설정하여, 미니맵 시스템을 다음과 같이 구조적으로 개선했습니다.<br>
                        <ul>
                            <li>기존의 Tick 기반 전체 아이콘 갱신 방식을 제거</li>
                            <li>객체 이동 이벤트 발생 시에만 해당 아이콘 위치를 업데이트하도록 변경</li>
                            <li>아이콘 생성 및 위치 갱신을 선별적으로 처리하여 연산량 최소화</li>
                        </ul>
                    </p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>성능 병목의 근본 원인 분석 및 구조적 개선:</strong> 단순한 최적화가 아닌, Tick 기반의 비효율적 폴링 구조를 이벤트 기반 방식으로 전환하는 구조적 접근을 통해 문제를 해결했습니다.</li>
                            <li><strong>설계 패턴의 확장 가능성:</strong> 이벤트 기반 최적화는 미니맵에만 국한되지 않고, 다른 시스템에도 적용 가능한 범용 설계 패턴으로 재정립했습니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5">핵심 구현 로직</div>
                    <pre><code class="language-cpp">// 미니맵에서 위치가 변경된 오브젝트만 선별하여 아이콘을 업데이트하는 로직
void UMiniMapViewModel::OnUpdateLocationUIDList(const FMiniMapUpdateLocationUIDListData&amp; UpdateList)
{
    // 위치가 변경된 오브젝트 리스트를 순회
    for (const TPair&lt;int64, FVector&gt;&amp; Pair : UpdateList.UpdateLocationUIDList)
    {
        // 해당 오브젝트의 아이콘을 찾거나, 없다면 새로 생성
        if (UUW_MiniMapObjectIcon* UnitIcon = GetOrCreateIcon(Pair.Key))
        {
            // 아이콘의 위치만 새로 업데이트 (전체 다시 그리기 방지)
            UnitIcon-&gt;UpdatePosition(Pair.Value);
        }
    }
}</code></pre>
                    <p>이 코드는 위치가 변경된 오브젝트만 선별적으로 처리하여, 전체 아이콘을 반복적으로 갱신하지 않고도 정확하고 효율적인 미니맵 업데이트를 가능하게 합니다.</p>

                     <div class="text-center my-4">
                        <figure class="figure mt-3 w-75">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 350" class="figure-img img-fluid rounded" alt="미니맵 최적화 전후 비교 다이어그램">
                                <style>
                                    .title { font-family: 'Muli', sans-serif; font-size: 20px; font-weight: bold; text-anchor: middle; fill: #343a40; }
                                    .box { fill: #f8f9fa; stroke: #6c757d; stroke-width: 2; }
                                    .box-text { font-family: 'Muli', sans-serif; font-size: 16px; text-anchor: middle; fill: #212529; }
                                    .arrow { fill: #6c757d; }
                                    .label { font-family: 'Muli', sans-serif; font-size: 14px; text-anchor: middle; }
                                    .bad { fill: #dc3545; }
                                    .good { fill: #28a745; }
                                </style>

                                <!-- 기존 방식 -->
                                <text x="200" y="40" class="title">기존 방식 (Tick 기반)</text>
                                <rect x="100" y="80" width="200" height="50" rx="10" class="box"/>
                                <text x="200" y="110" class="box-text">Every Frame (Tick)</text>
                                
                                <path d="M 200 130 L 200 155" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="75" y="160" width="250" height="50" rx="10" class="box"/>
                                <text x="200" y="190" class="box-text">모든 오브젝트 순회</text>

                                <path d="M 200 210 L 200 235" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="75" y="240" width="250" height="50" rx="10" class="box"/>
                                <text x="200" y="270" class="box-text">모든 아이콘 위치 업데이트</text>

                                <text x="200" y="320" class="label bad">CPU 부하 높음</text>

                                <!-- 개선된 방식 -->
                                <text x="600" y="40" class="title">개선된 방식 (이벤트 기반)</text>
                                <rect x="500" y="80" width="200" height="50" rx="10" class="box"/>
                                <text x="600" y="110" class="box-text">오브젝트 이동</text>

                                <path d="M 600 130 L 600 155" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="500" y="160" width="200" height="50" rx="10" class="box"/>
                                <text x="600" y="190" class="box-text">이벤트 발생</text>

                                <path d="M 600 210 L 600 235" stroke="#6c757d" stroke-width="2" marker-end="url(#arrowhead)"/>

                                <rect x="475" y="240" width="250" height="50" rx="10" class="box"/>
                                <text x="600" y="270" class="box-text">해당 아이콘만 위치 업데이트</text>

                                <text x="600" y="320" class="label good">CPU 부하 낮음</text>

                                <defs>
                                    <marker id="arrowhead" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#6c757d"/>
                                    </marker>
                                </defs>
                            </svg>
                            <figcaption class="figure-caption text-center">기존 Tick 기반 방식과 개선된 이벤트 기반 방식의 데이터 처리 흐름 비교</figcaption>
                        </figure>

                        <figure class="figure mt-5 w-75">
                            <img src="../../projects/projectR/image/Profiling.png" class="figure-img img-fluid rounded" alt="미니맵 프로파일링">
                            <figcaption class="figure-caption text-center">미니맵 업데이트 프로파일링 결과</figcaption>
                        </figure>
                    </div>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Content Implementation -->
            <section class="resume-section" id="content-implementation">
                <div class="resume-section-content">
                    <h2 class="mb-5">다양한 콘텐츠 시스템 구현</h2>
                    <p class="lead">
                        MMORPG의 핵심 재미를 구성하는 전투 외 콘텐츠 시스템을 다수 개발하여 게임의 깊이와 지속성을 강화했습니다. 단순한 기능 구현을 넘어, 모듈화된 구조와 데이터 기반 설계를 통해 <strong>확장성과 유지보수성</strong>을 고려한 콘텐츠 프레임워크를 구축했습니다.
                    </p>

                    <hr class="my-5">
                    <h3 class="mb-4">통합 맵 시스템</h3>
                    <div class="subheading mb-1">기능 개요</div>
                    <p class="mb-1">MMORPG 환경에서 플레이어의 위치 파악과 콘텐츠 접근성을 높이기 위해, 월드맵, 필드맵, 미니맵 세 종류의 맵 UI를 통합적으로 설계하고 구현했습니다.<br>
                        각 맵은 고유한 역할을 가지며, 공통 상호작용(이동, 확대/축소, 마우스 커서 기반 중심 이동 등)은 <code>UMapInteractionViewModel</code>을 통해 일관되게 처리됩니다.</p>
                    <ul>
                        <li><strong>월드맵:</strong> 전체 지역 구조와 필드맵 바로가기 기능 지원</li>
                        <li><strong>필드맵:</strong> 현재 지역 내 주요 지형과 NPC 위치를 표시, 자동 이동 및 즉시 이동 기능 지원</li>
                        <li><strong>미니맵:</strong> 실시간 퀘스트, 파티원, 수배 대상 등의 정보를 아이콘으로 표시하여 즉각적인 상황 판단 지원</li>
                    </ul>
                    <p>각 맵은 자신의 특성에 맞는 ViewModel(<code>WorldMapViewModel</code>, <code>FieldMapViewModel</code>, <code>MiniMapViewModel</code>)을 통해 공통 상호작용 로직을 재사용하면서도, 필요 시 자체 확장 로직을 추가할 수 있는 구조로 설계되었습니다.</p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>공통 기능 분리를 통한 재사용성 확보:</strong> 이동, 확대/축소 등 모든 맵에서 공통적으로 사용되는 기능을 <code>UMapInteractionViewModel</code>에 통합하여, 중복 코드를 제거하고 유지보수성을 높였습니다. 각 맵은 이 클래스를 개별 인스턴스로 소유하여 독립적으로 활용하면서도, 필요 시 자신만의 특화된 로직을 추가할 수 있어 유연하고 확장 가능한 아키텍처를 구축했습니다.</li>
                            <li><strong>맵 간 일관성 유지:</strong> 동일한 상호작용 방식과 UI 흐름을 유지함으로써, 플레이어가 맵 종류에 관계없이 일관된 조작 경험을 느낄 수 있도록 설계했습니다.</li>
                        </ul>
                    </p>
                    <p class="mt-4">
                        아래 다이어그램은 각 맵 뷰모델이 공통 상호작용 로직을 담당하는 <code>UMapInteractionViewModel</code> 인스턴스를 개별적으로 소유하여 활용하는 구조를 보여줍니다.
                        이를 통해 각 맵은 독립적으로 상호작용 기능을 사용하면서도, 필요에 따라 자신만의 특화된 로직을 추가할 수 있어 유연하고 확장 가능한 아키텍처를 제공합니다.
                    </p>
                    <div class="text-center my-3">
                        <figure class="figure w-75">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 180" class="figure-img img-fluid rounded" alt="통합 맵 시스템 아키텍처 다이어그램">
                                <style>
                                    .box { fill: #f8f9fa; stroke: #6c757d; stroke-width: 2; }
                                    .box-text { font-family: 'Muli', sans-serif; font-size: 16px; text-anchor: middle; fill: #212529; }
                                    .inner-box { fill: #e9ecef; stroke: #adb5bd; stroke-width: 1; }
                                    .inner-box-text { font-family: 'Muli', sans-serif; font-size: 14px; fill: #495057; }
                                    .arrow { fill: #6c757d; }
                                    .label { font-family: 'Muli', sans-serif; font-size: 14px; text-anchor: middle; }
                                </style>

                                <!-- WorldMapViewModel -->
                                <rect x="50" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="150" y="75" class="box-text">WorldMapViewModel</text>
                                <rect x="60" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="70" y="120" class="inner-box-text">UMapInteractionViewModel</text>

                                <!-- FieldMapViewModel -->
                                <rect x="300" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="400" y="75" class="box-text">FieldMapViewModel</text>
                                <rect x="310" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="320" y="120" class="inner-box-text">UMapInteractionViewModel</text>

                                <!-- MiniMapViewModel -->
                                <rect x="550" y="50" width="220" height="100" rx="10" class="box"/>
                                <text x="650" y="75" class="box-text">MiniMapViewModel</text>
                                <rect x="560" y="100" width="200" height="30" rx="5" class="inner-box"/>
                                <text x="570" y="120" class="inner-box-text">UMapInteractionViewModel</text>
                            </svg>
                            <figcaption class="figure-caption text-center mt-2">통합 맵 시스템 아키텍처: 각 뷰모델이 UMapInteractionViewModel을 소유하는 구조</figcaption>
                        </figure>
                    </div>

                    <hr class="my-5">
                    <h3 class="mb-4">유연하고 확장 가능한 데이터 기반 시스템 설계</h3>
                    <div class="subheading mb-1">설계 목적</div>
                    <p>
                       MMORPG의 복잡한 콘텐츠를 효율적으로 관리하고, 기획 변경이나 신규 기능 추가에 빠르게 대응할 수 있도록 <strong>데이터 기반의 모듈식 시스템</strong>을 설계했습니다.
                       각 기능(업적, 레이드, 스케줄 등)은 <strong>독립적인 데이터 모델</strong>로 분리되며, 모든 로직은 <strong>데이터 테이블에 의해 제어</strong>되도록 아키텍처를 구성했습니다.
                       기획자는 <strong>코드 수정 없이 데이터 조작만으로 콘텐츠를 추가하거나 밸런스를 조정</strong>할 수 있어, 개발 효율성과 라이브 운영 안정성을 동시에 확보할 수 있었습니다.
                    </p>
                    <p class="mb-2">
                        <strong class="text-navy-bold">개발 과정에서 중요하게 생각한 점</strong>
                        <ul>
                            <li><strong>관심사의 분리:</strong> 각 기능은 전용 모델에 책임을 집중시켜, 예를 들어 전투 로직은 <code>CombatModel</code>, 스케줄 로직은 <code>ScheduleModel</code>에 분리하여 기능 간 의존성을 최소화하고 유지보수성을 높였습니다.</li>
                            <li><strong>데이터 기반 설계:</strong> 핵심 로직은 데이터 테이블의 값에 따라 동작하도록 설계되어, 기획자가 직접 콘텐츠를 제어하고 빠르게 반복하며 개선할 수 있는 환경을 만들었습니다. 이는 라이브 서비스 환경에서 신속한 대응을 가능하게 했습니다.</li>
                            <li><strong>확장성:</strong> 새로운 기능이나 콘텐츠가 추가될 때, 기존 코드를 수정하기보다 새로운 모듈(모델, 스케줄러 등)을 추가하여 시스템이 확장되도록 구조를 설계했습니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5 mb-1">콘텐츠 스케줄 시스템 사례</div>
                    <p class="mb-1">
                        MMORPG에서 보스 출현, 던전 오픈, 이벤트 시작 등 다양한 콘텐츠의 활성 시점을 제어하기 위해 (데이터 기반 + 객체 생성 책임 분리 + 확장 가능한 구조)를 갖춘 콘텐츠 스케줄 시스템을 설계했습니다.
                        <ul>
                            <li><strong>데이터 테이블 중심 설계:</strong> 콘텐츠의 스케줄 정보(타입, 시작 시간, 반복 여부 등)는 데이터 테이블에 정의되며, 이 데이터를 기반으로 적절한 스케줄러를 동적으로 생성 및 관리합니다.</li>
                            <li><strong>팩토리 메서드 패턴 도입:</strong> 스케줄러 생성 책임은 <code>USchedulerFactoryBase</code>라는 추상 팩토리 클래스에 위임하고, 각 스케줄 타입에 대응하는 서브 팩토리 클래스(예: <code>UBossSchedulerFactory</code>, <code>UDungeonSchedulerFactory</code>)에서 생성 방식을 오버라이딩하여 다형성과 확장성을 확보했습니다.</li>
                            <li><strong>타입 기반 팩토리 매핑:</strong> <code>UScheduleModel</code>은 각 EScheduleType에 대응하는 팩토리 인스턴스를 등록하고, 스케줄 생성 시 해당 팩토리를 통해 스케줄러를 생성합니다.</li>
                        </ul>
                    </p>
                    <div class="subheading mt-5">핵심 구현 로직</div>
                    <pre><code class="language-cpp">//추상 팩토리
UCLASS(Abstract)
class USchedulerFactoryBase : public UObject
{
    GENERATED_BODY()

public:
    virtual UContentSchedulerBase* CreateScheduler(UObject* Outer, const FScheduleData & Data) = 0;
};

// 서브 팩토리 예시
UCLASS()
class UBossSchedulerFactory : public USchedulerFactoryBase
{
    GENERATED_BODY()

public:
    virtual UContentSchedulerBase* CreateScheduler(UObject* Outer, const FScheduleData & Data) override
    {
        UBossSpawnScheduler* Scheduler = NewObject<UBossSpawnScheduler>(Outer);
        Scheduler->Initialize(Data);
        return Scheduler;
    }
};

// 모델에서 팩토리 활용
void UScheduleModel::MakeScheduler(const FScheduleData & Data)
{
    if (USchedulerFactoryBase* Factory = FactoryMap.FindRef(Data.Type))
    {
        UContentSchedulerBase* Scheduler = Factory->CreateScheduler(this, Data);
        AddScheduler(Data.Type, Scheduler);
    }
}</code></pre>
                    <p>이 로직은 데이터 테이블에 정의된 스케줄 정보를 기반으로, 적절한 스케줄러 클래스를 선택해 인스턴스를 생성하고 초기화한 뒤, 모델에 등록하여 콘텐츠의 시간 제어를 동적으로 처리합니다.</p>

                    <hr class="my-5">
                    <h3 class="mb-4">주요 인게임 콘텐츠 개발</h3>
                    <p>
                        MMORPG의 핵심 재미를 구성하는 다양한 콘텐츠 개발에 참여했습니다.
                        특히 수많은 콘텐츠를 짧은 시간 내에 안정적으로 구현하기 위해, 모듈형 컴포넌트 설계와 유연한 데이터 구조를 기반으로 확장 가능한 콘텐츠 프레임워크를 구축하는 데 집중했습니다.
                    </p>
                    <div class="subheading mt-5 mb-1">레이드 던전</div>
                    <ul>
                        <li><strong>개발 목표:</strong> 여러 플레이어가 협력하여 보스를 공략하는 레이드 콘텐츠를 모듈화된 구조로 설계하여, 다양한 유형의 던전을 손쉽게 추가할 수 있는 기반을 마련했습니다.</li>
                        <li><strong>설계 방식</strong>
                            <ul style="list-style-position: inside; padding-left: 1rem;">
                                <li>모든 던전의 공통 기능(예: 제한 시간 관리, 입장 처리 등)은 <code>UBaseDungeonModel</code>에 캡슐화</li>
                                <li>각 던전 유형은 이를 상속받아 특화된 로직만 재정의하는 방식으로 구현</li>
                                <li>덕분에 코드 재사용성과 유지보수성이 크게 향상되었으며, 새로운 던전 추가 시 기존 로직을 수정하지 않고 확장이 가능했습니다</li>
                            </ul>
                        </li>
                    </ul>
                        <pre><code class="language-cpp">// 모든 던전에서 공통적으로 사용하는 시간 제한 로직을 기본 클래스에 정의
class UBaseDungeonModel
{
public:
    // 던전 시작 시 공통적으로 제한 시간 타이머를 작동시킴
    virtual void Start()
    {
        CountdownTimer-&gt;OnFinished.AddDynamic(this, &amp;UBaseDungeonModel::OnTimeOver);
        CountdownTimer-&gt;Start(DungeonTimeLimit);
    }

protected:
    // 시간이 다 되었을 때 호출될 공통 로직
    virtual void OnTimeOver() 
    {
        // 던전 실패 처리
    } 

    UPROPERTY()
    UCountdownTimer* CountdownTimer; // 시간 제한을 관리하는 오브젝트
};

// OnTimeOver()를 재정의하여 콘텐츠별 실패 처리 방식 분리
class BossRaidModel : public UBaseDungeonModel
{
protected:
    // UBaseDungeonModel OnTimeOver를 재정의(override)
    virtual void OnTimeOver() override
    {
        // 보스 레이드에 맞는 실패 UI를 띄우고, 추가 보상 로직 등을 처리
        ShowBossRaidFailureUI();
    }
};</code></pre>
                    <div class="subheading mt-5 mb-1">배틀 아레나(PVP)</div>
                    <ul>
                        <li><strong>개발 목표:</strong> 다른 플레이어와 실력을 겨루는 PVP 콘텐츠인 배틀 아레나는 전투의 몰입도와 전략적 긴장감을 극대화하기 위해 시간에 따라 좁혀지는 안전 구역(자기장)과 맵 내 아이템 생성 이벤트를 포함한 다양한 변수 기반 시스템으로 설계했습니다.</li>
                        <li><strong>설계 방식</strong>
                            <ul style="list-style-position: inside; padding-left: 1rem;">
                                <li>서버로부터 전달되는 이벤트 타입에 따라 자기장 조정, 아이템 생성, 특수 상황 처리 등을 유연하게 대응할 수 있도록 타입 기반 이벤트 처리 시스템을 설계했습니다.</li>
                                <li>EArenaEventType에 따라 다양한 이벤트를 처리할 수 있으며, 새로운 이벤트가 추가될 경우 switch 문에 분기만 추가하면 확장 가능합니다.</li>
                            </ul>
                        </li>
                    </ul>
                    <pre><code class="language-cpp">// 배틀 아레나에서 발생하는 이벤트를 타입에 따라 처리하는 로직
void UBattleArenaPlaySystem::ProcessArenaEvent(const FArenaEvent&amp; EventData)
{
    EArenaEventType EventType = EventData.Type;

    switch (EventType)
    {
        case EArenaEventType::ShrinkSafeZone: // 안전 구역 축소
        {
            UpdateSafeZone(EventData.ZoneInfo);
            break;
        }
        case EArenaEventType::SpawnSpecialItem: // 지정된 위치에 특별 아이템 생성
        {
            SpawnItemOnMap(EventData.ItemInfo, EventData.SpawnLocation);
            break;
        }
        // ... 기타 이벤트 처리 ...
    }
}</code></pre>
                    <div class="subheading mt-5 mb-1">업적 및 시즌패스</div>
                    <ul>
                        <li>플레이어의 성취감을 높이고 지속적인 동기를 부여하는 업적 시스템과 시즌패스 보상 시스템을 구현했습니다.</p></li>
                    </ul>
                    <div class="subheading mt-3 mb-1">우편 및 소환 상점</div>
                    <ul>
                        <li>게임 내 재화나 아이템을 주고받는 우편 시스템과, 재화를 통한 뽑기를 제공하는 소환 상점 시스템을 개발하여 게임의 경제 시스템을 뒷받침했습니다.</li>
                    </ul>
                    <div class="subheading mt-3 mb-1">절전 모드</div>
                    <ul>
                        <li>캐릭터 상태와 획득 아이템 등 핵심 정보는 실시간으로 표시하는 절전 모드를 구현했습니다.</li>
                    </ul>
                    <div class="subheading mt-3 mb-1">마을 내 편의 기능</div>
                    <ul>
                        <li>마을 내 UI에서 NPC 리스트를 제공하여 선택 시 해당 위치로 자동 이동할 수 있는 기능을 개발하여, 플레이어가 넓은 마을에서 원하는 NPC를 쉽게 찾을 수 있도록 했습니다.</li>
                    </ul>
                </div>
            </section>
            <hr class="m-0" />

            <!-- Growth -->
            <section class="resume-section" id="growth">
                <div class="resume-section-content">
                    <h2 class="mb-5">성장</h2>
                    <h3 class="mb-4">Unreal Engine 5 기반 대규모 프로젝트 경험</h3>
                    <p>MMORPG 환경에서 실시간 렌더링, 크로스플랫폼 대응(PC/모바일) 등 고난도의 기술 과제를 해결하며 Unreal Engine 5에 대한 깊은 이해와 실전 적용 능력을 갖추게 되었습니다.</p>
                     <ul>
                        <li>MVVM 아키텍처를 활용한 UI/로직 분리 및 유지보수성 향상</li>
                        <li>오브젝트 풀링을 통한 메모리 효율화 및 성능 안정화</li>
                        <li>이벤트 기반 시스템을 활용한 콘텐츠 흐름 제어 및 확장성 확보</li>
                    </ul>
                    <p>복잡한 시스템을 직접 설계하고 구현하는 과정에서 언리얼의 내부 구조와 최적화 기법을 심도 있게 익혔습니다.</p>
                    
                    <hr class="my-5">
                    <h3 class="mb-4">협업을 통한 시스템 설계 및 개선 역량 강화</h3>
                    <p>
                        복잡한 콘텐츠 시스템을 설계하고 개선하는 과정에서 기획자, 클라이언트 개발자, 서버 개발자와 긴밀하게 협력하며 요구사항을 분석하고 기술적 제약을 조율해 실현 가능한 구조로 구체화했습니다.<br>
                        예를 들어, 레이드 시스템과 보스 스케줄 기능을 설계할 때는 전투 흐름과 콘텐츠 활성 타이밍을 서버와 동기화하는 구조를 제안하고, 자동 전투 로직과 스킬 처리 컴포넌트를 모듈화하여 각 팀원이 독립적으로 개발 및 테스트할 수 있는 기반을 마련했습니다.
                        이러한 경험을 통해 단순한 기능 구현을 넘어서, 팀 전체의 개발 생산성과 시스템 완성도를 높이는 데 실질적인 기여를 할 수 있었습니다.
                    </p>
                    <ul>
                        <li><code>UAttackProcessor</code>에 상태 머신 패턴을 도입하여 전투 흐름을 명확하게 구조화</li>
                        <li><code>UAutoCombatProcessor</code>, <code>UAutoSkillComponent</code>에 지능형 로직을 구현하여 자동 전투 시스템의 전략성과 확장성을 강화</li>
                        <li>모듈화된 구조를 통해 재사용성과 유지보수성을 높이며 팀 전체의 개발 생산성 향상에 기여</li>
                    </ul>

                    <hr class="my-5">

                    <h3 class="mb-4">디버깅 및 성능 개선 역량 강화</h3>
                    <p>실전 환경에서 발생한 다양한 문제를 해결하며 디버깅과 최적화 역량을 키웠습니다.</p>
                    <ul>
                        <li>미니맵 최적화 과정에서 불필요한 연산 제거 및 메모리 누수, 댕글링 포인터 해결</li>
                        <li>Unreal Insights와 같은 전문 프로파일링 툴을 활용하여 실시간 성능 분석 및 병목 지점 추적 수행</li>
                        <li><code>TSoftObjectPtr</code> 기반의 리소스 관리와 오브젝트 풀링을 통해 안정적인 게임 플레이 환경을 제공</li>
                    </ul></h3>
                </div>
            </section>
        </div>

        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>  
        <!-- Core theme JS-->
        <script src="../../js/scripts.js"></script>
    </body>
</html>
